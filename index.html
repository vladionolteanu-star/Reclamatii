<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mobexpert CRM Analytics - Home & Deco Intelligence Platform</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="icon" href="data:,">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&family=JetBrains+Mono:wght@400;600;700&display=swap');
    
    * { 
      font-family: 'Inter', sans-serif;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .mono { 
      font-family: 'JetBrains Mono', monospace;
      letter-spacing: 0.5px;
    }
    
    body { 
      background: #000000;
      background-image: 
        radial-gradient(ellipse at top left, rgba(34, 197, 94, 0.03) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(34, 197, 94, 0.02) 0%, transparent 50%);
    }
    
    #matrixCanvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      pointer-events: none; 
      z-index: 1;
      opacity: 0.7;
    }
    
    .login-content { 
      position: relative; 
      z-index: 10; 
      backdrop-filter: blur(20px) saturate(180%);
      background: linear-gradient(135deg, rgba(5, 5, 5, 0.9) 0%, rgba(10, 10, 10, 0.85) 100%);
      border: 1px solid rgba(34, 197, 94, 0.15);
      box-shadow: 
        0 0 80px rgba(34, 197, 94, 0.1),
        0 20px 60px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      animation: fadeInUp 0.6s ease-out;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .dashboard-gradient { 
      background: linear-gradient(180deg, #080808 0%, #0f0f0f 50%, #080808 100%);
      min-height: 100vh;
      position: relative;
    }
    
    .dashboard-gradient::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(34, 197, 94, 0.01) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(34, 197, 94, 0.01) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .card-dark { 
      background: linear-gradient(145deg, rgba(15, 15, 15, 0.95), rgba(10, 10, 10, 0.98));
      border: 1px solid rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(20px);
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.02),
        inset 0 -1px 0 rgba(0, 0, 0, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    .card-dark::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent,
        rgba(34, 197, 94, 0.1),
        transparent
      );
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .card-dark:hover::before {
      opacity: 1;
    }
    
    .input-dark { 
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: #ffffff;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
    }
    
    .input-dark:hover {
      background: rgba(0, 0, 0, 0.8);
      border-color: rgba(34, 197, 94, 0.2);
    }
    
    .input-dark:focus { 
      background: rgba(0, 0, 0, 0.9);
      border-color: rgba(34, 197, 94, 0.4);
      box-shadow: 
        0 0 0 3px rgba(34, 197, 94, 0.1),
        0 0 20px rgba(34, 197, 94, 0.1);
      outline: none;
    }
    
    .btn-cyber { 
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: #000000;
      font-weight: 600;
      position: relative;
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 4px 20px rgba(34, 197, 94, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        inset 0 -2px 0 rgba(0, 0, 0, 0.2);
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .btn-cyber::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .btn-cyber:hover::before {
      left: 100%;
    }
    
    .btn-cyber:hover { 
      transform: translateY(-2px) scale(1.02);
      box-shadow: 
        0 8px 30px rgba(34, 197, 94, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .btn-cyber:active {
      transform: translateY(0) scale(0.98);
    }
    
    .btn-danger { 
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: #ffffff;
      font-weight: 600;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      box-shadow: 
        0 2px 8px rgba(239, 68, 68, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }
    
    .btn-danger:hover { 
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }
    
    .table-dark { 
      background: rgba(5, 5, 5, 0.6);
      backdrop-filter: blur(20px);
      border-radius: 0 0 12px 12px;
    }
    
    .table-dark thead { 
      background: linear-gradient(180deg, rgba(34, 197, 94, 0.06), rgba(34, 197, 94, 0.02));
      border-bottom: 1px solid rgba(34, 197, 94, 0.1);
      backdrop-filter: blur(10px);
    }
    
    .table-dark thead th {
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, rgba(10, 10, 10, 0.98), rgba(5, 5, 5, 0.95));
      backdrop-filter: blur(20px);
      z-index: 10;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .table-dark tbody tr { 
      border-bottom: 1px solid rgba(255, 255, 255, 0.02);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .table-dark tbody tr:hover { 
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(34, 197, 94, 0.03) 50%, 
        transparent 100%
      );
      transform: scale(1.01);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .table-container-sticky { 
      max-height: 65vh;
      overflow-y: auto;
      overflow-x: auto;
      border-radius: 0 0 12px 12px;
    }
    
    .table-dark tbody tr.no-orders-after-complaint { 
      background: linear-gradient(90deg, 
        rgba(239, 68, 68, 0.08),
        rgba(239, 68, 68, 0.12),
        rgba(239, 68, 68, 0.08)
      ) !important;
      animation: pulseRed 2s ease-in-out infinite;
    }
    
    @keyframes pulseRed {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    .table-dark tbody tr.no-orders-after-complaint:hover { 
      background: linear-gradient(90deg, 
        rgba(239, 68, 68, 0.15),
        rgba(239, 68, 68, 0.2),
        rgba(239, 68, 68, 0.15)
      ) !important;
    }
    
    ::-webkit-scrollbar { 
      width: 10px;
      height: 10px;
    }
    
    ::-webkit-scrollbar-track { 
      background: rgba(0, 0, 0, 0.8);
      border-radius: 5px;
    }
    
    ::-webkit-scrollbar-thumb { 
      background: linear-gradient(180deg, rgba(34, 197, 94, 0.6), rgba(34, 197, 94, 0.4));
      border-radius: 5px;
      border: 1px solid rgba(0, 0, 0, 0.5);
    }
    
    ::-webkit-scrollbar-thumb:hover { 
      background: linear-gradient(180deg, rgba(34, 197, 94, 0.8), rgba(34, 197, 94, 0.6));
    }
    
    .mobexpert-brand { 
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 50%, #22c55e 100%);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 900;
      font-size: 1.5rem;
      letter-spacing: -0.02em;
      animation: shimmer 3s ease-in-out infinite;
    }
    
    @keyframes shimmer {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    .pagination-btn { 
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(34, 197, 94, 0.05));
      border: 1px solid rgba(34, 197, 94, 0.2);
      color: #22c55e;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
    }
    
    .pagination-btn:hover:not(:disabled) { 
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1));
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
    }
    
    .pagination-btn:disabled { 
      opacity: 0.3;
      cursor: not-allowed;
      filter: grayscale(0.5);
    }
    .segment-badge { 
      padding: 3px 10px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
    }
    
    .segment-badge:hover {
      transform: scale(1.05);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
    }
    
    .segment-vip { 
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      color: #000000;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .segment-loyal { 
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: #ffffff;
    }
    
    .segment-growth { 
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      color: #ffffff;
    }
    
    .segment-newcomer { 
      background: linear-gradient(135deg, #10b981, #059669);
      color: #ffffff;
    }
    
    .segment-declining { 
      background: linear-gradient(135deg, #f97316, #ea580c);
      color: #ffffff;
    }
    
    .segment-atrisk { 
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: #ffffff;
    }
    
    .segment-dormant { 
      background: linear-gradient(135deg, #6b7280, #4b5563);
      color: #ffffff;
    }
    
    .segment-lost { 
      background: linear-gradient(135deg, #991b1b, #7f1d1d);
      color: #ffffff;
    }
    
    .segment-complaint { 
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: #ffffff;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .score-tooltip { 
      position: absolute;
      background: linear-gradient(135deg, rgba(5, 5, 5, 0.98), rgba(10, 10, 10, 0.95));
      border: 1px solid rgba(34, 197, 94, 0.2);
      padding: 16px;
      border-radius: 12px;
      z-index: 10000;
      min-width: 320px;
      max-width: 400px;
      display: none;
      font-size: 11px;
      line-height: 1.8;
      box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.8),
        0 0 60px rgba(34, 197, 94, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      pointer-events: none;
      animation: tooltipFadeIn 0.3s ease;
    }
    
    @keyframes tooltipFadeIn {
      from { 
        opacity: 0;
        transform: translateY(-10px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .loading-overlay { 
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.98), rgba(0, 0, 0, 1));
      display: none;
      z-index: 9999;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }
    
    .file-item { 
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.08), rgba(34, 197, 94, 0.05));
      border: 1px solid rgba(34, 197, 94, 0.15);
      padding: 10px 14px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      transition: all 0.2s ease;
    }
    
    .file-item:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.12), rgba(34, 197, 94, 0.08));
      border-color: rgba(34, 197, 94, 0.25);
      transform: translateX(4px);
    }
    
    .filter-badge { 
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 700;
      margin-left: 6px;
      transition: all 0.2s ease;
    }
    
    .email-yes { 
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.15));
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }
    
    .email-no { 
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.15));
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.2);
    }
    
    @keyframes shake { 
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }
    
    /* Stats Cards Animation */
    #statsCards > div {
      animation: cardSlideIn 0.6s ease-out forwards;
      opacity: 0;
      transform: translateY(20px);
    }
    
    #statsCards > div:nth-child(1) { animation-delay: 0.1s; }
    #statsCards > div:nth-child(2) { animation-delay: 0.2s; }
    #statsCards > div:nth-child(3) { animation-delay: 0.3s; }
    #statsCards > div:nth-child(4) { animation-delay: 0.4s; }
    #statsCards > div:nth-child(5) { animation-delay: 0.5s; }
    #statsCards > div:nth-child(6) { animation-delay: 0.6s; }
    #statsCards > div:nth-child(7) { animation-delay: 0.7s; }
    #statsCards > div:nth-child(8) { animation-delay: 0.8s; }
    
    @keyframes cardSlideIn {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Select and Input Premium Style */
    select.input-dark, input.input-dark {
      cursor: pointer;
      font-size: 12px;
      padding: 8px 12px;
    }
    
    select.input-dark option {
      background: #000000;
      color: #22c55e;
    }
    
    /* File Input Premium Style */
    input[type="file"] {
      cursor: pointer;
    }
    
    input[type="file"]::-webkit-file-upload-button {
      cursor: pointer;
    }
    /* Stiluri pentru Dashboard-ul de Predicții */
.ml-dashboard {
  background: linear-gradient(145deg, rgba(15, 15, 15, 0.95), rgba(10, 10, 10, 0.98));
  border: 1px solid rgba(147, 51, 234, 0.2);
  border-radius: 16px;
  padding: 24px;
  margin: 24px 0;
}

.prediction-card {
  background: rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(147, 51, 234, 0.1);
  border-radius: 12px;
  padding: 16px;
  margin: 12px 0;
  transition: all 0.3s ease;
}

.prediction-card:hover {
  border-color: rgba(147, 51, 234, 0.3);
  transform: translateY(-2px);
}

.prediction-score {
  font-size: 2rem;
  font-weight: bold;
  background: linear-gradient(135deg, #9333ea, #7c3aed);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.category-chip {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  margin: 2px;
  background: rgba(147, 51, 234, 0.1);
  border: 1px solid rgba(147, 51, 234, 0.2);
  color: #9333ea;
}
    /* Stiluri pentru ML Enhanced */
.ml-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(15px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.ml-popup {
  background: linear-gradient(145deg, #101010, #0A0A0A);
  border: 1px solid rgba(147, 51, 234, 0.2);
  border-radius: 16px;
  padding: 24px;
  max-width: 800px;
  width: 95%;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0,0,0,0.7), 0 0 80px rgba(147, 51, 234, 0.15);
  animation: slideUp 0.4s ease-out;
}

@keyframes slideUp {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.ml-badge {
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
}

.ml-high { background: linear-gradient(135deg, #22c55e, #16a34a); color: #fff; }
.ml-medium { background: linear-gradient(135deg, #f59e0b, #d97706); color: #fff; }
.ml-low { background: linear-gradient(135deg, #ef4444, #dc2626); color: #fff; }
  </style>
</head>
</head>
<body class="bg-black text-gray-100">
  <div id="loadingOverlay" class="loading-overlay">
    <div class="text-center">
      <div class="mobexpert-brand text-4xl mb-4">MOBEXPERT CRM</div>
      <div class="text-green-400 mono text-sm mb-4" id="loadingText">Procesare date...</div>
      <div class="w-80 bg-gradient-to-r from-gray-900 to-gray-800 rounded-full h-3 overflow-hidden border border-green-500/20">
        <div id="loadingProgress" class="h-3 bg-gradient-to-r from-green-600 to-green-400 rounded-full transition-all duration-500 shadow-lg shadow-green-500/50" style="width: 0%"></div>
      </div>
      <div class="mt-4 text-gray-500 text-xs mono opacity-60" id="loadingDetails"></div>
    </div>
  </div>

  <div id="scoreTooltip" class="score-tooltip"></div>
  
  <div id="storyOverlay" class="fixed inset-0 bg-black/90 backdrop-blur-md items-center justify-center z-[999] overflow-y-auto" style="display: none;">
    <div id="storyModal" class="bg-gradient-to-br from-gray-900 to-black border border-green-500/20 rounded-2xl shadow-2xl p-8 max-w-2xl w-full mx-4 my-8 relative">
      <button onclick="hideStoryModal()" class="absolute top-4 right-4 w-10 h-10 rounded-full bg-red-500/20 text-red-400 hover:bg-red-500/30 hover:text-white transition-all flex items-center justify-center text-xl font-bold z-10">×</button>
      <h2 class="text-xl font-bold text-green-400 mb-6 mono tracking-wide">Analiză Client</h2>
      <div id="storyContent" class="text-sm text-gray-300 leading-relaxed space-y-4 max-h-[70vh] overflow-y-auto pr-2"></div>
      <button onclick="hideStoryModal()" class="absolute top-4 right-4 w-8 h-8 rounded-full bg-red-500/20 text-red-400 hover:bg-red-500/30 hover:text-white transition-all flex items-center justify-center">&times;</button>
      <h2 class="text-xl font-bold text-green-400 mb-6 mono tracking-wide">Analiză Client</h2>
      <div id="storyContent" class="text-sm text-gray-300 leading-relaxed space-y-4"></div>
    </div>
  </div>

  <div id="passwordOverlay" class="fixed inset-0 bg-black flex items-center justify-center z-50">
    <canvas id="matrixCanvas"></canvas>
    <div class="login-content p-12 rounded-3xl shadow-2xl max-w-md w-full mx-4">
      <div class="text-center mb-10">
        <h1 class="mobexpert-brand mb-3 text-4xl">MOBEXPERT CRM</h1>
        <h2 class="text-2xl font-bold text-green-400 mono tracking-wider">HOME & DECO INTELLIGENCE</h2>
        <p class="text-green-500/40 text-xs mono mt-3 tracking-widest">SECURE ACCESS REQUIRED</p>
      </div>
      <div class="space-y-6">
        <input type="password" id="passwordInput" class="w-full p-5 rounded-xl mono text-sm input-dark" placeholder="Enter access code" autocomplete="off">
        <button onclick="checkPassword()" class="w-full btn-cyber py-5 rounded-xl mono text-sm tracking-wider font-bold">AUTHENTICATE</button>
      </div>
    </div>
  </div>

  <div class="hidden" id="mainContent">
    <div class="dashboard-gradient min-h-screen">
      <div class="p-6 bg-gradient-to-b from-black/50 to-black/30 backdrop-blur-xl border-b border-gray-800/50 sticky top-0 z-10">
        <div class="flex items-center justify-between mb-6">
          <div class="flex items-center space-x-6">
            <h1 class="mobexpert-brand text-3xl">MOBEXPERT CRM</h1>
            <span class="px-3 py-1 bg-green-500/10 text-green-400 text-xs mono rounded-full border border-green-500/20">v5.0 HOME & DECO</span>
          </div>
          <div class="flex items-center space-x-6">
            <button onclick="exportResults()" class="btn-cyber px-6 py-3 rounded-xl text-sm font-semibold tracking-wide">Export CSV</button>
            <button onclick="exportResults()" class="btn-cyber px-6 py-3 rounded-xl text-sm font-semibold tracking-wide">Generează Listă Săptămânală</button>
            <div class="text-xs text-gray-400 mono space-x-3">
              <span class="text-gray-500">Total:</span>
              <span class="text-white font-bold" id="totalCustomers">0</span> clienți
              <span class="text-gray-600">|</span>
              <span class="text-white font-bold" id="totalTransactions">0</span> tranzacții
              <span class="text-gray-600">|</span>
              <span class="filter-badge email-yes">✓ Email: <span id="withEmail">0</span></span>
              <span class="filter-badge email-no">✗ Email: <span id="withoutEmail">0</span></span>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-7 gap-4">
          <div>
            <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Date Vânzări</label>
            <input type="file" id="salesCsvInput" multiple accept=".csv" class="w-full text-xs text-gray-400 file:mr-2 file:py-2 file:px-3 file:rounded-lg file:border-0 file:text-xs file:bg-gradient-to-r file:from-blue-600 file:to-blue-500 file:text-white hover:file:from-blue-700 hover:file:to-blue-600 file:transition-all file:shadow-md cursor-pointer">
            <div id="filesList" class="mt-3 max-h-32 overflow-y-auto space-y-2"></div>
          </div>
          
          <div>
            <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Reclamații</label>
            <input type="file" id="complaintsCsvInput" accept=".csv" class="w-full text-xs text-gray-400 file:mr-2 file:py-2 file:px-3 file:rounded-lg file:border-0 file:text-xs file:bg-gradient-to-r file:from-red-600 file:to-red-500 file:text-white hover:file:from-red-700 hover:file:to-red-600 file:transition-all file:shadow-md cursor-pointer">
          </div>
          
          <div>
            <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Perioadă</label>
            <select id="analysisPeriod" class="w-full p-2.5 input-dark rounded-lg text-xs">
              <option value="all">Toată perioada</option>
              <option value="6">Ultimii 6 ani</option>
              <option value="5">Ultimii 5 ani</option>
              <option value="4">Ultimii 4 ani</option>
              <option value="3">Ultimii 3 ani</option>
              <option value="2" selected>Ultimii 2 ani</option>
              <option value="1">Ultimul an</option>
            </select>
          </div>
          
          <div>
            <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Email</label>
            <select id="filterEmail" class="w-full p-2.5 input-dark rounded-lg text-xs">
              <option value="all">Toți</option>
              <option value="with">Cu email</option>
              <option value="without">Fără email</option>
            </select>
          </div>
          
          <div>
            <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Segment</label>
            <select id="filterSegment" class="w-full p-2.5 input-dark rounded-lg text-xs">
              <option value="all">Toate segmentele</option>
              <option value="VIP Champions">VIP Champions</option>
              <option value="Loyal Customers">Loyal Customers</option>
              <option value="Growth Potential">Growth Potential</option>
              <option value="New Customers">New Customers</option>
              <option value="Declining">Declining</option>
              <option value="At Risk">At Risk</option>
              <option value="Dormant">Dormant</option>
              <option value="Lost">Lost</option>
              <option value="Complaint Risk">Complaint Risk</option>
            </select>
          </div>

          <div>
  <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Filtre Comportament</label>
  <div class="p-2.5 input-dark rounded-lg flex flex-col items-start space-y-2 h-auto">
    <label for="filterHasComplaint" class="flex items-center space-x-2 cursor-pointer group">
      <input type="checkbox" id="filterHasComplaint" class="w-4 h-4 rounded bg-gray-900 border-gray-600 text-green-500 focus:ring-green-600 cursor-pointer">
      <span class="text-xs text-gray-400 group-hover:text-white transition-colors">CU RECLAMAȚII</span>
    </label>
    <label for="filterReadyPurchase" class="flex items-center space-x-2 cursor-pointer group">
      <input type="checkbox" id="filterReadyPurchase" class="w-4 h-4 rounded bg-gray-900 border-gray-600 text-green-500 focus:ring-green-600 cursor-pointer">
      <span class="text-xs text-gray-400 group-hover:text-white transition-colors">GATA DE ACHIZIȚIE</span>
    </label>
    <label for="filterOverduePurchase" class="flex items-center space-x-2 cursor-pointer group">
      <input type="checkbox" id="filterOverduePurchase" class="w-4 h-4 rounded bg-gray-900 border-gray-600 text-green-500 focus:ring-green-600 cursor-pointer">
      <span class="text-xs text-gray-400 group-hover:text-white transition-colors">PERIOADĂ DEPĂȘITĂ</span>
    </label>
  </div>
</div>
          
          <div>
            <label class="block text-xs text-gray-500 mb-2 mono uppercase tracking-wider">Căutare</label>
            <input type="text" id="searchInput" placeholder="ID / Email / Segment..." class="w-full p-2.5 input-dark rounded-lg text-xs">
          </div>
        </div>
      </div>

      <div class="p-8">
        <div id="statsCards" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4 mb-8" style="display: none;">
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">Total Clienți</p>
            <p id="statTotalCustomers" class="text-3xl font-bold text-white">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">VIP Champions</p>
            <p id="statChampions" class="text-3xl font-bold text-yellow-400">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">At Risk</p>
            <p id="statAtRisk" class="text-3xl font-bold text-orange-400">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">Lost</p>
            <p id="statLost" class="text-3xl font-bold text-red-400">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">Cu Reclamații</p>
            <p id="statComplaints" class="text-3xl font-bold text-purple-400">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">Pierdut după</p>
            <p id="statNoOrdersAfterComplaint" class="text-3xl font-bold text-red-500">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">Val. Medie</p>
            <p id="statAvgValue" class="text-3xl font-bold text-green-400">0</p>
          </div>
          <div class="card-dark p-5 rounded-xl hover:scale-105 transition-transform cursor-pointer">
            <p class="text-xs text-gray-500 uppercase tracking-wide mb-2">Sezonalitate</p>
            <p id="statSeasonality" class="text-2xl font-bold text-blue-400">-</p>
          </div>
        </div>
        <div id="mlPredictionsContainer"></div>

        <div class="card-dark rounded-2xl overflow-hidden">
          <div class="p-5 border-b border-gray-800/50 bg-gradient-to-r from-transparent via-green-500/5 to-transparent">
            <h3 class="text-xl font-bold text-white">Analiză Detaliată Clienți - Home & Deco</h3>
          </div>
          
          <div class="overflow-x-auto table-container-sticky">
            <table class="table w-full text-sm table-dark">
              <thead>
                <tr class="text-xs mono uppercase tracking-wider text-gray-400">
                  <th class="px-4 py-4 text-left">#</th>
                  <th class="px-4 py-4 text-left">ID Client</th>
                  <th class="px-4 py-4 text-left">Email</th>
                  <th class="px-4 py-4 text-left">Segment</th>
                  <th class="px-4 py-4 text-right cursor-help" title="Click pentru detalii">Scor</th>
                  <th class="px-4 py-4 text-right">Trend</th>
                  <th class="px-4 py-4 text-right">Prima Achiziție</th>
                  <th class="px-4 py-4 text-right">Ultima Achiziție</th>
                  <th class="px-4 py-4 text-right">Zile Inactiv</th>
                  <th class="px-4 py-4 text-right">Valoare Totală</th>
                  <th class="px-4 py-4 text-right">Nr. Facturi</th>
                  <th class="px-4 py-4 text-right">Val. Medie</th>
                  <th class="px-4 py-4 text-center">Reclamație</th>
                  <th class="px-4 py-4 text-left">Status Post-Recl</th>
                  <th class="px-4 py-4 text-center">Analiză</th>
                </tr>
              </thead>
              <tbody id="customersTableBody" class="text-sm text-gray-300"></tbody>
            </table>
          </div>
          
          <div id="pagination" class="p-5 border-t border-gray-800/50 bg-gradient-to-r from-transparent via-gray-800/20 to-transparent"></div>
        </div>

        <!-- Restul continuă neschimbat de la charts în jos -->
<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-8">
            <div class="card-dark rounded-2xl overflow-hidden">
                <div class="p-5 border-b border-gray-800/50 bg-gradient-to-r from-transparent via-green-500/5 to-transparent">
                    <h2 class="text-lg font-bold text-white">Distribuție Segmente Home & Deco</h2>
                </div>
                <div class="p-8 bg-gradient-to-br from-gray-900/50 to-black/50">
                    <canvas id="segmentsChart" style="max-height: 300px;"></canvas>
                </div>
            </div>
            
            <div class="card-dark rounded-2xl overflow-hidden">
                <div class="p-5 border-b border-gray-800/50 bg-gradient-to-r from-transparent via-red-500/5 to-transparent">
                    <h2 class="text-lg font-bold text-white">Impact Reclamații & Trend</h2>
                </div>
                <div class="p-8 bg-gradient-to-br from-gray-900/50 to-black/50">
                    <canvas id="complaintsChart" style="max-height: 300px;"></canvas>
                </div>
            </div>
        </div>

        <div class="card-dark rounded-2xl mt-8 overflow-hidden">
            <div class="p-5 border-b border-gray-800/50 bg-gradient-to-r from-transparent via-blue-500/5 to-transparent">
                <h2 class="text-xl font-bold text-white flex items-center space-x-3">
                    <span class="text-2xl">📊</span>
                    <span>Metodologie Adaptată Mobexpert</span>
                </h2>
            </div>
            <div class="p-8 space-y-6 text-sm">
                <div class="bg-gradient-to-br from-black/60 to-gray-900/30 p-6 rounded-xl border border-green-500/10">
                    <h3 class="text-green-400 font-bold mb-4 text-base">Segmentare RFM pentru Home & Deco</h3>
                    <div class="grid grid-cols-3 gap-4 text-xs">
                        <div class="bg-gradient-to-br from-yellow-900/20 to-black/50 p-4 rounded-lg border border-yellow-500/20">
                            <strong class="text-yellow-400 text-sm block mb-2">Recency (R)</strong>
                            <div class="space-y-1 text-gray-400">
                                <div>• 0-6 luni: <span class="text-yellow-300 font-bold">R=5</span></div>
                                <div>• 6-12 luni: <span class="text-yellow-300 font-bold">R=4</span></div>
                                <div>• 1-2 ani: <span class="text-yellow-300 font-bold">R=3</span></div>
                                <div>• 2-4 ani: <span class="text-yellow-300 font-bold">R=2</span></div>
                                <div>• >4 ani: <span class="text-yellow-300 font-bold">R=1</span></div>
                            </div>
                        </div>
                        <div class="bg-gradient-to-br from-blue-900/20 to-black/50 p-4 rounded-lg border border-blue-500/20">
                            <strong class="text-blue-400 text-sm block mb-2">Frequency (F)</strong>
                            <div class="space-y-1 text-gray-400">
                                <div>• 1 factură: <span class="text-blue-300 font-bold">F=1</span></div>
                                <div>• 2-3 facturi: <span class="text-blue-300 font-bold">F=2</span></div>
                                <div>• 4-6 facturi: <span class="text-blue-300 font-bold">F=3</span></div>
                                <div>• 7-12 facturi: <span class="text-blue-300 font-bold">F=4</span></div>
                                <div>• 13+ facturi: <span class="text-blue-300 font-bold">F=5</span></div>
                            </div>
                        </div>
                        <div class="bg-gradient-to-br from-purple-900/20 to-black/50 p-4 rounded-lg border border-purple-500/20">
                            <strong class="text-purple-400 text-sm block mb-2">Monetary (M)</strong>
                            <div class="space-y-1 text-gray-400">
                                <div>• <500 RON: <span class="text-purple-300 font-bold">M=1</span></div>
                                <div>• 500-2K RON: <span class="text-purple-300 font-bold">M=2</span></div>
                                <div>• 2K-5K RON: <span class="text-purple-300 font-bold">M=3</span></div>
                                <div>• 5K-10K RON: <span class="text-purple-300 font-bold">M=4</span></div>
                                <div>• >10K RON: <span class="text-purple-300 font-bold">M=5</span></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gradient-to-br from-black/60 to-gray-900/30 p-6 rounded-xl border border-blue-500/10">
                    <h3 class="text-green-400 font-bold mb-4 text-base">Scor Complex Adaptat (0-100)</h3>
                    <div class="grid grid-cols-2 gap-3 text-xs">
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Recența</span>
                            <span class="text-green-400 font-bold">30%</span>
                        </div>
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Val. Medie/Cmd</span>
                            <span class="text-blue-400 font-bold">25%</span>
                        </div>
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Cross-sell</span>
                            <span class="text-purple-400 font-bold">15%</span>
                        </div>
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Vechime</span>
                            <span class="text-yellow-400 font-bold">10%</span>
                        </div>
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Tip Produs</span>
                            <span class="text-orange-400 font-bold">10%</span>
                        </div>
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Trend</span>
                            <span class="text-pink-400 font-bold">5%</span>
                        </div>
                        <div class="flex justify-between items-center p-2 bg-black/30 rounded-lg">
                            <span class="text-gray-400">Frecv. Facturi</span>
                            <span class="text-indigo-400 font-bold">5%</span>
                        </div>
                    </div>
                </div>

                <div class="bg-gradient-to-r from-green-900/30 via-blue-900/20 to-purple-900/30 p-6 rounded-xl border border-green-500/30">
                    <p class="text-sm text-gray-300 leading-relaxed">
                        <strong class="text-green-400 text-base block mb-3">📌 Praguri Valoare Mobexpert</strong>
                        <div class="grid grid-cols-2 gap-3 text-xs">
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                                <span class="text-gray-400">Decorațiuni: <strong class="text-white">&lt;500 RON</strong></span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-yellow-400 rounded-full"></span>
                                <span class="text-gray-400">Mobilier mic: <strong class="text-white">500-2500 RON</strong></span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-blue-400 rounded-full"></span>
                                <span class="text-gray-400">Mobilier principal: <strong class="text-white">&gt;6000 RON</strong></span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-red-400 rounded-full"></span>
                                <span class="text-gray-400">Client pierdut: <strong class="text-white">&gt;2 ani</strong></span>
                            </div>
                        </div>
                    </p>
                </div>
            </div>
        </div>
      </div>
    </div>
  </div>
<script>  
    // --- START: MOBEXPERT WORKER CODE (FROM PART 1) ---
    const workerCode = `
      self.onmessage = function(e) {
        const { salesData, complaintsData, analysisPeriod } = e.data;
        const now = new Date();
        let cutoffDate = null;
        if (analysisPeriod !== 'all') {
            cutoffDate = new Date();
            cutoffDate.setFullYear(now.getFullYear() - parseInt(analysisPeriod));
        }

        // Helper function to parse dates with multiple formats
        function parseDate(dateStr) {
            if (!dateStr || dateStr === 'Invalid Date' || dateStr === 'null' || dateStr === 'NA' || dateStr === '#N/A') {
                return null;
            }
            
            const str = dateStr.toString().trim();
            
            // Try different formats
            const formats = [
                // dd.mm.yyyy
                () => {
                    const parts = str.split('.');
                    if (parts.length === 3) {
                        const day = parseInt(parts[0], 10);
                        const month = parseInt(parts[1], 10) - 1;
                        const year = parseInt(parts[2], 10);
                        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                            return new Date(year, month, day);
                        }
                    }
                    return null;
                },
                // dd/mm/yyyy
                () => {
                    const parts = str.split('/');
                    if (parts.length === 3) {
                        // Check if it's dd/mm/yyyy or mm/dd/yyyy
                        const part1 = parseInt(parts[0], 10);
                        const part2 = parseInt(parts[1], 10);
                        const year = parseInt(parts[2], 10);
                        
                        // Assume dd/mm/yyyy if first part > 12
                        if (part1 > 12 || part2 <= 12) {
                            return new Date(year, part2 - 1, part1);
                        } else {
                            return new Date(year, part1 - 1, part2);
                        }
                    }
                    return null;
                },
                // yyyy-mm-dd
                () => {
                    if (str.match(/^\\d{4}-\\d{2}-\\d{2}/)) {
                        const d = new Date(str);
                        return isNaN(d.getTime()) ? null : d;
                    }
                    return null;
                },
                // Direct parse as last resort
                () => {
                    const d = new Date(str);
                    return isNaN(d.getTime()) ? null : d;
                }
            ];
            
            for (const formatter of formats) {
                try {
                    const d = formatter();
                    if (d && !isNaN(d.getTime()) && d.getFullYear() > 1900 && d.getFullYear() < 2100) {
                        return d;
                    }
                } catch (e) {
                    continue;
                }
            }
            
            return null;
        }

        // STAGE 1: Aggregate sales data
        self.postMessage({ type: 'progress', text: 'Agregare tranzacții...', details: '0%', percent: 10 });
        const customerMap = {};
        let totalInvoices = 0;
        
        for (let i = 0; i < salesData.length; i++) {
          const sale = salesData[i];
          const saleDate = parseDate(sale.date);
          
          if (!saleDate) continue;
          if (cutoffDate && saleDate < cutoffDate) continue;

          if (!customerMap[sale.id]) {
            customerMap[sale.id] = { 
              id: sale.id, 
              email: 'N/A', 
              transactions: [], 
              total_value: 0, 
              unique_days: new Set(),
              monthly_purchases: {},
              purchase_cycles: 0,
              small_purchases: 0,
              large_purchases: 0,
              product_categories: new Set(),
              invoice_count: 0
            };
          }
          const customer = customerMap[sale.id];
          customer.transactions.push({ date: saleDate, value: sale.value, invoices: sale.invoices || 1 });
          customer.total_value += sale.value;
          customer.unique_days.add(sale.date);
          customer.invoice_count += (sale.invoices || 1);
          totalInvoices += (sale.invoices || 1);
          
          // Calculate purchase cycles based on invoice frequency
const invoiceContribution = sale.invoices || 1;
customer.purchase_cycles += invoiceContribution * 0.3;

// Categorize purchases - SIMPLIFICAT pentru Home & Deco
if (sale.value >= 6000) {
    customer.large_purchases++;
    customer.product_categories.add('mobilier_principal');
} else if (sale.value >= 500) {
    customer.product_categories.add('mobilier_mic');
} else {
    customer.product_categories.add('decoratiuni');
}

// Track monthly for seasonality
const monthKey = saleDate.getFullYear() + '-' + (saleDate.getMonth() + 1);
customer.monthly_purchases[monthKey] = (customer.monthly_purchases[monthKey] || 0) + sale.value;

// Handle email
const emailStr = String(sale.email || '').trim();
if (emailStr &&
    emailStr.toLowerCase() !== 'n/a' &&
    emailStr.toLowerCase() !== 'na' &&
    emailStr.toLowerCase() !== 'null' &&
    emailStr !== '#N/A' &&
    emailStr !== '#null') {
    customer.email = emailStr;
}

if (i % 10000 === 0) {
    const progress = Math.floor((i / salesData.length) * 30);
    self.postMessage({ 
        type: 'progress', 
        text: 'Agregare tranzacții...', 
        details: \`\${i.toLocaleString('ro-RO')} / \${salesData.length.toLocaleString('ro-RO')}\`, 
        percent: 10 + progress 
    });
}
}

// STAGE 2: Process metrics for RFM and advanced scoring
self.postMessage({ type: 'progress', text: 'Calculare metrici Home & Deco...', details: '', percent: 40 });

// Funcție nouă pentru calcul trend RAFINAT
function calculateRefinedTrend(transactions) {
    // Trend se calculează DOAR pentru clienți cu istoric solid
    if (transactions.length < 10) {
        return {
            trend: 50, // Valoare neutră pentru clienți fără istoric suficient
            confidence: 'low',
            pattern: 'insufficient_data'
        };
    }
    
    // Sortăm tranzacțiile cronologic
    const sorted = [...transactions].sort((a, b) => a.date - b.date);
    
    // Împărțim în 3 perioade egale pentru analiză mai granulară
    const third = Math.floor(sorted.length / 3);
    const period1 = sorted.slice(0, third);
    const period2 = sorted.slice(third, third * 2);
    const period3 = sorted.slice(third * 2);
    
    // Calculăm metrici pentru fiecare perioadă
    const getMetrics = (period) => {
        const values = period.map(t => t.value);
        const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
        const maxValue = Math.max(...values);
        const minValue = Math.min(...values);
        
        // Calculăm intervalul mediu între achiziții
        let avgInterval = 0;
        if (period.length > 1) {
            const intervals = [];
            for (let i = 1; i < period.length; i++) {
                const days = (period[i].date - period[i-1].date) / (1000 * 60 * 60 * 24);
                if (days > 0) intervals.push(days);
            }
            avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        }
        
        return {
            avgValue,
            maxValue,
            minValue,
            count: period.length,
            avgInterval,
            variance: values.reduce((sum, v) => sum + Math.pow(v - avgValue, 2), 0) / values.length
        };
    };
    
    const metrics1 = getMetrics(period1);
    const metrics2 = getMetrics(period2);
    const metrics3 = getMetrics(period3);
    
    // Calculăm trend-uri multiple
    const valueTrend = ((metrics3.avgValue - metrics1.avgValue) / metrics1.avgValue) * 100;
    const frequencyTrend = metrics3.avgInterval > 0 ? 
        ((metrics1.avgInterval - metrics3.avgInterval) / metrics1.avgInterval) * 100 : 0;
    const maxValueTrend = ((metrics3.maxValue - metrics1.maxValue) / metrics1.maxValue) * 100;
    
    // Detectăm pattern-uri
    let pattern = 'stable';
    if (valueTrend > 30 && frequencyTrend > 20) {
        pattern = 'ascending_strong';
    } else if (valueTrend > 15 || frequencyTrend > 10) {
        pattern = 'ascending_moderate';
    } else if (valueTrend < -30 && frequencyTrend < -20) {
        pattern = 'declining_strong';
    } else if (valueTrend < -15 || frequencyTrend < -10) {
        pattern = 'declining_moderate';
    } else if (metrics3.variance > metrics1.variance * 2) {
        pattern = 'volatile';
    }
    
    // Calculăm scorul final de trend (0-100)
    let trendScore = 50; // Start neutru
    
    // Adăugăm/scădem bazat pe tendințe
    trendScore += Math.min(25, Math.max(-25, valueTrend / 4));
    trendScore += Math.min(15, Math.max(-15, frequencyTrend / 6));
    trendScore += Math.min(10, Math.max(-10, maxValueTrend / 10));
    
    // Ajustăm pentru volatilitate
    const volatilityRatio = metrics3.variance / (metrics1.variance || 1);
    if (volatilityRatio > 3) {
        trendScore *= 0.8; // Penalizare pentru instabilitate
    }
    
    // Limitare între 0 și 100
    trendScore = Math.max(0, Math.min(100, trendScore));
    
    return {
        trend: Math.round(trendScore),
        confidence: transactions.length >= 20 ? 'high' : 'medium',
        pattern: pattern,
        metrics: {
            valueTrend: valueTrend.toFixed(1),
            frequencyTrend: frequencyTrend.toFixed(1),
            periods: [metrics1, metrics2, metrics3]
        }
    };
}

let customerMetrics = Object.values(customerMap).map(c => {
    // Verificare esențială: dacă un client nu are tranzacții, returnează un obiect gol pentru a evita erori
    if (c.transactions.length === 0) {
        return null; 
    }

    const sortedTransactions = c.transactions.sort((a, b) => a.date - b.date);
    const last_purchase = sortedTransactions[sortedTransactions.length - 1].date;
    const first_purchase = sortedTransactions[0].date;
    const daysSinceLastPurchase = Math.floor((now - last_purchase) / (1000 * 60 * 60 * 24));
    const customerLifetime = Math.floor((last_purchase - first_purchase) / (1000 * 60 * 60 * 24)) || 1;
    
    // --- CALCULELE SUNT ACUM TOATE ÎN INTERIORUL FUNCȚIEI .map() ---
    
    // 1. Calculăm sezonalitate
    const seasonality = { 'Iarnă': 0, 'Primăvară': 0, 'Vară': 0, 'Toamnă': 0 };
    c.transactions.forEach(t => {
        const month = t.date.getMonth();
        if ([11, 0, 1].includes(month)) seasonality['Iarnă']++;
        else if ([2, 3, 4].includes(month)) seasonality['Primăvară']++;
        else if ([5, 6, 7].includes(month)) seasonality['Vară']++;
        else seasonality['Toamnă']++;
    });
    const preferredSeason = Object.keys(seasonality).reduce((a, b) => seasonality[a] > seasonality[b] ? a : b);

    // 2. Interval mediu de cumpărare
    let avgPurchaseInterval = 0;
    if (sortedTransactions.length > 1) {
        const intervals = [];
        for (let i = 1; i < sortedTransactions.length; i++) {
            const diff = (sortedTransactions[i].date - sortedTransactions[i - 1].date) / (1000 * 60 * 60 * 24);
            if (diff > 0) intervals.push(diff);
        }
        if (intervals.length > 0) {
             avgPurchaseInterval = Math.round(intervals.reduce((a, b) => a + b, 0) / intervals.length);
        }
    }
    
    // 3. Folosim noul calcul de trend
    const trendAnalysis = calculateRefinedTrend(c.transactions);
    
    c.purchase_cycles = Math.round(c.purchase_cycles);
    if (c.purchase_cycles < 1) c.purchase_cycles = 1;
    
    // 4. Determinăm tipul de client bazat pe comportament
    let customerType = 'Standard';
    if (c.large_purchases >= 2) customerType = 'Premium';
    else if (c.large_purchases >= 1) customerType = 'Valuable';
    else if (c.product_categories.size >= 3) customerType = 'Diverse';
    
    const hasValidEmail = c.email && c.email !== 'N/A' && 
        c.email.toLowerCase() !== 'na' && 
        c.email.toLowerCase() !== 'null' && 
        c.email.includes('@');
    
    // Returnăm obiectul final cu toate datele calculate corect
    return {
        id: c.id, 
        email: c.email, 
        has_email: hasValidEmail,
        recency: daysSinceLastPurchase, 
        frequency: c.unique_days.size,
        monetary: c.total_value, 
        avg_order_value: c.total_value / c.transactions.length,
        last_purchase: last_purchase, 
        first_purchase: first_purchase,
        customer_lifetime: customerLifetime, 
        transactions: c.transactions,
        purchase_cycles: c.purchase_cycles, 
        invoice_count: c.invoice_count,
        product_categories: c.product_categories.size, 
        customer_type: customerType,
        trend_monetary: trendAnalysis.trend,
        trend_pattern: trendAnalysis.pattern,
        trend_confidence: trendAnalysis.confidence,
        preferred_season: preferredSeason,
        avg_purchase_interval: avgPurchaseInterval,
        monthly_purchases: c.monthly_purchases
    };
}).filter(Boolean); // Adaugă .filter(Boolean) pentru a elimina clienții nuli (fără tranzacții)
        
        // Continue with RFM scoring...
        self.postMessage({ type: 'progress', text: 'Calculare scoruri RFM...', details: '', percent: 50 });
    `;
    // --- END: WORKER CODE PART 1 ---
    
    // Password check function (needed here for button to work)
    function checkPassword() {
        const password = document.getElementById('passwordInput').value;
        if (password === '333') {
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('mainContent').classList.remove('hidden');
            setupEventListeners();
        } else {
            document.getElementById('passwordInput').style.animation = 'shake 0.5s';
            setTimeout(() => {
                document.getElementById('passwordInput').style.animation = '';
                document.getElementById('passwordInput').value = '';
            }, 500);
        }
    }
    
    // Placeholder for setupEventListeners (will be defined in part 2)
    function setupEventListeners() {
        // This will be properly defined in part 2
    }

    // --- START: CONTENT FROM PART 2 SCRIPT ---
    const workerCodePart2 = `
        // RFM Score Functions
        const getRecencyScore = (days) => {
          if (days <= 180) return 5;     // 0-6 months
          if (days <= 365) return 4;     // 6-12 months
          if (days <= 730) return 3;     // 1-2 years
          if (days <= 1460) return 2;    // 2-4 years
          return 1;                      // >4 years
        };
        
        const getFrequencyScore = (cycles) => {
          if (cycles === 0) return 1;
          if (cycles <= 1) return 2;
          if (cycles <= 3) return 3;
          if (cycles <= 6) return 4;
          return 5;  // 7+ cycles
        };
        
        const getMonetaryScore = (avgValue) => {
          if (avgValue < 500) return 1;
          if (avgValue < 2000) return 2;
          if (avgValue < 5000) return 3;
          if (avgValue < 10000) return 4;
          return 5;
        };

        let customersData = customerMetrics.map(c => {
            const rfm = {
              r: getRecencyScore(c.recency),
              f: getFrequencyScore(c.purchase_cycles),
              m: getMonetaryScore(c.avg_order_value)
            };
            return {...c, rfm_score: rfm };
        });
        customerMetrics = null; // Free memory

        // STAGE 4: Determine Segments & Complex Score
        self.postMessage({ type: 'progress', text: 'Calcul scor complex și segmentare...', details: '', percent: 70 });
        
        const determineSegment = (r, f, m, recency, cycles, monetary, lifetime) => {
    // VIP Champions - cei mai valoroși
    if (monetary > 20000 && f >= 4 && r >= 3) return 'VIP Champions';
    if (monetary > 15000 && f >= 3 && r >= 4) return 'VIP Champions';
    
    // Loyal Customers - constanți și valoroși
    if (lifetime > 730 && f >= 3 && monetary > 5000) return 'Loyal Customers';
    if (r >= 3 && f >= 3 && m >= 3) return 'Loyal Customers';
    
    // Growth Potential - recent activi cu potențial
    if (r >= 4 && monetary > 2000 && f <= 2) return 'Growth Potential';
    if (recency < 180 && cycles <= 2 && monetary > 1000) return 'Growth Potential';
    
    // New Customers - foarte recenți
    if (lifetime < 90 && cycles <= 1) return 'New Customers';
    if (r === 5 && f === 1) return 'New Customers';
    
    // Declining - în scădere dar recuperabili
    if (recency > 365 && recency <= 540 && monetary > 3000) return 'Declining';
    if (r === 2 && m >= 3) return 'Declining';
    
    // At Risk - risc real de pierdere
    if (recency > 540 && recency <= 730 && monetary > 5000) return 'At Risk';
    if (recency > 450 && recency <= 730 && f >= 3) return 'At Risk';
    
    // Dormant - inactivi prelungit
    if (recency > 730 && recency <= 1095 && monetary > 1000) return 'Dormant';
    if (r === 1 && f >= 2 && recency < 1095) return 'Dormant';
    
    // Lost - pierduți definitiv
    if (recency > 1095) return 'Lost';
    if (recency > 730 && monetary < 1000) return 'Lost';
    
    // Default pentru restul
    return 'At Risk';
};
        
const calculateMobexpertScore = (customer) => {
    // Calculează trend doar pentru clienți cu istoric amplu (>12 luni și >5 tranzacții)
    let trendScore = 50; // Default neutru
    if (customer.transactions.length >= 5 && customer.customer_lifetime > 365) {
        const midPoint = Math.floor(customer.transactions.length / 2);
        const firstHalf = customer.transactions.slice(0, midPoint);
        const secondHalf = customer.transactions.slice(midPoint);
        
        const avgFirst = firstHalf.reduce((sum, t) => sum + t.value, 0) / firstHalf.length;
        const avgSecond = secondHalf.reduce((sum, t) => sum + t.value, 0) / secondHalf.length;
        
        const percentChange = ((avgSecond - avgFirst) / avgFirst) * 100;
        trendScore = Math.min(100, Math.max(0, 50 + (percentChange * 2)));
    }
    
    // Scoruri recalculate cu focus pe valoare totală și vechime
    const totalValueScore = Math.min(100, (customer.monetary / 50000) * 100);
    const lifetimeScore = Math.min(100, (customer.customer_lifetime / 1460) * 100); // Max 4 ani
    const frequencyScore = Math.min(100, (customer.invoice_count / 20) * 100);
    const recencyScore = Math.max(0, 100 - (customer.recency / 365) * 50); // Penalizare mai blândă
    const avgOrderScore = Math.min(100, (customer.avg_order_value / 5000) * 100);
    
    // PONDERI NOI - mai multă valoare pe total, vechime și frecvență
    const complexScore = (
        totalValueScore * 0.30 +    // 30% valoare totală
        lifetimeScore * 0.25 +       // 25% vechime
        frequencyScore * 0.20 +      // 20% frecvență
        recencyScore * 0.15 +        // 15% recență
        avgOrderScore * 0.07 +       // 7% valoare medie
        trendScore * 0.03            // 3% trend (doar informativ)
    );
    
    return {
        score: Math.round(complexScore),
        components: {
            recency: recencyScore.toFixed(1),
            avgOrder: avgOrderScore.toFixed(1),
            crossSell: (customer.product_categories * 20).toFixed(1),
            lifetime: lifetimeScore.toFixed(1),
            productType: 50,
            trend: trendScore.toFixed(1),
            totalValue: totalValueScore.toFixed(1),
            frequency: frequencyScore.toFixed(1)
        }
    };
};

        customersData = customersData.map(c => {
            const complexScoring = calculateMobexpertScore(c);
            return {
                ...c,
                segment: determineSegment(c.rfm_score.r, c.rfm_score.f, c.rfm_score.m, c.recency, c.purchase_cycles, c.monetary, c.customer_lifetime),
                score: complexScoring.score,
                score_components: complexScoring.components
            };
        });

        // STAGE 5: Integrate complaints
        self.postMessage({ type: 'progress', text: 'Integrare reclamații...', details: '', percent: 90 });
        const complaintsMap = {};
        
        for (const complaint of complaintsData) {
            const complaintDate = parseDate(complaint.date);
            
            if (complaintDate) {
                if (!complaintsMap[complaint.id]) complaintsMap[complaint.id] = [];
                complaintsMap[complaint.id].push({
                    ...complaint,
                    date: complaintDate
                });
            }
        }

        customersData.forEach(customer => {
            if (complaintsMap[customer.id]) {
                customer.has_complaint = true;
                const complaints = complaintsMap[customer.id];
                customer.complaints = complaints;
                
                // Find last complaint date
                const lastComplaint = complaints.reduce((latest, c) => {
                    return c.date > latest.date ? c : latest;
                });
                customer.last_complaint_date = lastComplaint.date;
                
// LOGICĂ RAFINATĂ: Verifică dacă un client e pierdut după reclamație
                const lastComplaintDate = lastComplaint.date;
                const hasPurchasesAfter = customer.transactions.some(t => new Date(t.date) > new Date(lastComplaintDate));

                // Perioada de grație: 6 luni. Doar după acest timp îl considerăm "la risc".
                // Data curentă este 19.09.2025
                const gracePeriodCutoff = new Date('2025-09-19');
                gracePeriodCutoff.setMonth(gracePeriodCutoff.getMonth() - 6);

                // Un client este considerat PIERDUT doar dacă:
                // 1. NU a mai cumpărat nimic după ultima reclamație.
                // 2. Ultima lui reclamație este MAI VECHE de 6 luni.
                if (!hasPurchasesAfter && new Date(lastComplaintDate) < gracePeriodCutoff) {
                    customer.no_orders_after_complaint = true;
                } else {
                    customer.no_orders_after_complaint = false;
                }
                
                // Override segment if complaint risk
                if (customer.no_orders_after_complaint) {
                    customer.original_segment = customer.segment;
                    customer.segment = 'Complaint Risk';
                }
            } else {
                customer.has_complaint = false;
                customer.complaints = [];
                customer.last_complaint_date = null;
                customer.no_orders_after_complaint = false;
            }
            
            // Mark as Lost if no purchase in 2+ years
            if (customer.recency > 730 && customer.segment !== 'Complaint Risk') {
                customer.segment = 'Lost';
            }
        });
        
        customersData.sort((a,b) => b.monetary - a.monetary);
        self.postMessage({ type: 'complete', data: customersData, totalInvoices: totalInvoices });
      };
    `;

    // Combine worker parts
    const fullWorkerCode = workerCode + workerCodePart2;
    
    // Global variables
    let customersData = [];
    let totalTransactions = 0;
    let currentPage = 1;
    const rowsPerPage = 50;
    let segmentsChart = null;
    let complaintsChart = null;
    let allFiles = [];
    
    // Matrix Rain Effect
    class MatrixRain {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.resize();
            this.columns = [];
            this.init();
            window.addEventListener('resize', () => this.resize());
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.fontSize = 14;
            this.columnCount = Math.floor(this.canvas.width / this.fontSize);
        }

        init() {
            for(let i = 0; i < this.columnCount; i++) {
                this.columns[i] = Math.floor(Math.random() * this.canvas.height / this.fontSize);
            }
        }

        draw() {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = '#22c55e';
            this.ctx.font = this.fontSize + 'px monospace';
            
            for(let i = 0; i < this.columns.length; i++) {
                const text = String.fromCharCode(Math.floor(Math.random() * 128));
                const x = i * this.fontSize;
                const y = this.columns[i] * this.fontSize;
                
                this.ctx.fillText(text, x, y);
                
                if(y > this.canvas.height && Math.random() > 0.98) {
                    this.columns[i] = 0;
                }
                this.columns[i]++;
            }
        }
    }

    // Start Matrix Rain
    document.addEventListener('DOMContentLoaded', function() {
        const matrixCanvas = document.getElementById('matrixCanvas');
        const matrix = new MatrixRain(matrixCanvas);
        setInterval(() => matrix.draw(), 35);
        
        // Focus password field
        document.getElementById('passwordInput').focus();
        document.getElementById('passwordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') checkPassword();
        });
    });

    // Password check (redefined here to be the primary one)
    function checkPassword() {
        const password = document.getElementById('passwordInput').value;
        if (password === '333') {
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('mainContent').classList.remove('hidden');
            setupEventListeners();
        } else {
            document.getElementById('passwordInput').style.animation = 'shake 0.5s';
            setTimeout(() => {
                document.getElementById('passwordInput').style.animation = '';
                document.getElementById('passwordInput').value = '';
            }, 500);
        }
    }

    // Setup event listeners (the full function)
    function setupEventListeners() {
        document.getElementById('salesCsvInput').addEventListener('change', handleFileInput);
        document.getElementById('complaintsCsvInput').addEventListener('change', handleComplaintsInput);
        document.getElementById('analysisPeriod').addEventListener('change', reprocessData);
        document.getElementById('filterSegment').addEventListener('change', renderTable);
        document.getElementById('filterEmail').addEventListener('change', renderTable);
        document.getElementById('searchInput').addEventListener('input', renderTable);
        document.getElementById('filterHasComplaint').addEventListener('change', renderTable); // <-- LINIA NOUĂ
      document.getElementById('filterReadyPurchase').addEventListener('change', renderTable);
document.getElementById('filterOverduePurchase').addEventListener('change', renderTable);
    }
    // Handle multiple sales files
    function handleFileInput(event) {
        const files = Array.from(event.target.files);
        allFiles = files;
        displayFiles();
        
        if (files.length === 0) return;
        
        const complaintsInput = document.getElementById('complaintsCsvInput');
        if (complaintsInput.files.length > 0) {
            processCsvFiles(files, complaintsInput.files[0]);
        }
    }

    // Display uploaded files
    function displayFiles() {
        const filesList = document.getElementById('filesList');
        filesList.innerHTML = allFiles.map(file => {
            const size = (file.size / 1024).toFixed(1);
            return `<div class="file-item">
                <span class="text-xs">${file.name} (${size} KB)</span>
                <button onclick="removeFile('${file.name}')" class="btn-danger">×</button>
            </div>`;
        }).join('');
    }

    // Remove file
    function removeFile(fileName) {
        allFiles = allFiles.filter(f => f.name !== fileName);
        displayFiles();
        
        // Create new FileList
        const dt = new DataTransfer();
        allFiles.forEach(file => dt.items.add(file));
        document.getElementById('salesCsvInput').files = dt.files;
        
        if (allFiles.length === 0) {
            customersData = [];
            renderTable();
            updateStats();
        } else {
            const complaintsInput = document.getElementById('complaintsCsvInput');
            if (complaintsInput.files.length > 0) {
                processCsvFiles(allFiles, complaintsInput.files[0]);
            }
        }
    }

    // Handle complaints input
    function handleComplaintsInput(event) {
        const complaintsFile = event.target.files[0];
        if (allFiles.length > 0 && complaintsFile) {
            processCsvFiles(allFiles, complaintsFile);
        }
    }

    // Parse date helper
    function parseDate(dateStr) {
        if (!dateStr || dateStr === 'Invalid Date' || dateStr === 'null' || dateStr === 'NA') return null;
        
        const str = dateStr.toString().trim();
        
        // Try dd.mm.yyyy format
        if (str.includes('.')) {
            const parts = str.split('.');
            if (parts.length === 3) {
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10) - 1;
                const year = parseInt(parts[2], 10);
                if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                    return new Date(year, month, day);
                }
            }
        }
        
        // Try dd/mm/yyyy format
        if (str.includes('/')) {
            const parts = str.split('/');
            if (parts.length === 3) {
                const part1 = parseInt(parts[0], 10);
                const part2 = parseInt(parts[1], 10);
                const year = parseInt(parts[2], 10);
                
                if (part1 > 12 || part2 <= 12) {
                    return new Date(year, part2 - 1, part1);
                } else {
                    return new Date(year, part1 - 1, part2);
                }
            }
        }
        
        // Try ISO format
        const d = new Date(str);
        return isNaN(d.getTime()) ? null : d;
    }

    // --- START: CONTENT FROM PART 3 SCRIPT ---
    // Process CSV files with Web Worker
    function processCsvFiles(salesFiles, complaintsFile) {
        showLoading('Inițializare procesare...');
        
        Promise.all([
            ...salesFiles.map(file => readAndParseCSV(file, 'sales')),
            complaintsFile ? readAndParseCSV(complaintsFile, 'complaints') : Promise.resolve([])
        ]).then(results => {
            const complaintsData = complaintsFile ? results[results.length - 1] : [];
            const allSalesData = results.slice(0, -1).flat();
            
            totalTransactions = allSalesData.length;
            document.getElementById('totalTransactions').textContent = totalTransactions.toLocaleString('ro-RO');
            
            const analysisPeriod = document.getElementById('analysisPeriod').value;
            
            // Create and run worker
            const blob = new Blob([fullWorkerCode], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob));
            
            worker.postMessage({
                salesData: allSalesData,
                complaintsData: complaintsData,
                analysisPeriod: analysisPeriod
            });
            
            worker.onmessage = function(e) {
                if (e.data.type === 'progress') {
                    updateLoading(e.data.text, e.data.details, e.data.percent);
                } else if (e.data.type === 'complete') {
                    customersData = e.data.data;
                    totalInvoices = e.data.totalInvoices || 0;
                    hideLoading();
                    renderTable();
                    updateStats();
                    renderCharts();
                    document.getElementById('statsCards').style.display = 'grid';
                    worker.terminate();
                }
            };
            
            worker.onerror = function(error) {
                console.error('Worker error:', error);
                hideLoading();
                alert('Eroare la procesarea datelor: ' + error.message);
            };
        }).catch(error => {
            console.error('Error processing files:', error);
            hideLoading();
            alert('Eroare la citirea fișierelor: ' + error.message);
        });
    }

// Read and parse CSV
    function readAndParseCSV(file, type) {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    const data = results.data.map(row => {
                       if (!row) { // Adăugat pentru siguranță, ignoră rândurile complet goale
                           return null;
                       }
                       if (type === 'sales') {
                           const extractProductName = (row) => {
                               const possibleColumns = [
                                   'DENUMIRE ARTICOL', 'DENUMIRE_ARTICOL', 'Product Name', 
                                   'Product', 'Articol', 'Produs'
                               ];
                               for (const col of possibleColumns) {
                                   if (row[col]) return row[col];
                               }
                               return 'Unknown';
                           };

                           return {
                               id: row['ID CLIENT'] || row['ID_CLIENT'] || row['Customer ID'] || '',
                               email: row['EMAIL CLIENT'] || row['EMAIL_CLIENT'] || row['Email'] || 'N/A',
                               date: row['DATA'] || row['Date'] || '',
                               value: parseFloat(row['VALOARE FACTURATA'] || row['VALOARE_FACTURATA'] || row['Value'] || 0) || 0,
                               invoices: parseInt(row['NR FACTURI'] || row['NR_FACTURI'] || row['Invoices'] || 1) || 1,
                               store: row['MAGAZIN'] || row['Store'] || 'Unknown',
                               product_name: extractProductName(row) 
                           };
                       } else if (type === 'complaints') {
                           // ACEASTA ESTE PARTEA NOUĂ CARE REPARĂ EROAREA
                           return {
                               id: row['ID CLIENT'] || row['ID_CLIENT'] || row['Customer ID'] || '',
                               date: row['DATA'] || row['Date'] || ''
                           };
                       }
                       return null; // Asigură-te că returnezi null pentru orice alt caz
                    }).filter(row => row && row.id && row.id !== '' && row.id !== 'null'); // Filtrul este acum mai sigur
                    resolve(data);
                },
                error: function(error) {
                    reject(error);
                }
            });
        });
    }

    // Reprocess data
    function reprocessData() {
        if (allFiles.length > 0) {
            const complaintsInput = document.getElementById('complaintsCsvInput');
            processCsvFiles(allFiles, complaintsInput.files[0] || null);
        }
    }

function getFilteredData() {
    let filtered = [...customersData];

    // Filter by email
    const emailFilter = document.getElementById('filterEmail').value;
    if (emailFilter === 'with') {
        filtered = filtered.filter(c => c.has_email === true);
    } else if (emailFilter === 'without') {
        filtered = filtered.filter(c => c.has_email === false);
    }

    // Filter by segment
    const segmentFilter = document.getElementById('filterSegment').value;
    if (segmentFilter !== 'all') {
        filtered = filtered.filter(c => c.segment === segmentFilter);
    }

    // Filter by complaint checkbox
    const complaintFilter = document.getElementById('filterHasComplaint').checked;
    if (complaintFilter) {
        filtered = filtered.filter(c => c.has_complaint === true);
    }

    // LOGICĂ NOUĂ PENTRU MOBEXPERT
    const readyForPurchase = document.getElementById('filterReadyPurchase').checked;
    const overduePurchase = document.getElementById('filterOverduePurchase').checked;

    if (readyForPurchase) {
        filtered = filtered.filter(c => {
            // Client relevant: minim 10 tranzacții, peste 10k RON total, interval mediu calculabil
            if (c.invoice_count < 10 || c.monetary < 10000 || c.avg_purchase_interval <= 0) return false;
            
            // Fereastra de achiziție: între interval-60 zile și interval+60 zile
            const minDays = c.avg_purchase_interval - 60;
            const maxDays = c.avg_purchase_interval + 60;
            return c.recency >= minDays && c.recency <= maxDays;
        });
    }

    if (overduePurchase) {
        filtered = filtered.filter(c => {
            // Client relevant: minim 10 tranzacții, peste 10k RON total, interval mediu calculabil
            if (c.invoice_count < 10 || c.monetary < 10000 || c.avg_purchase_interval <= 0) return false;
            
            // Perioadă depășită: peste interval+90 zile, dar sub 730 zile (2 ani)
            return c.recency > (c.avg_purchase_interval + 90) && c.recency < 730;
        });
    }

    // Search filter
    const search = document.getElementById('searchInput').value.toLowerCase();
    if (search) {
        filtered = filtered.filter(c => 
            String(c.id).toLowerCase().includes(search) ||
            c.email.toLowerCase().includes(search) ||
            (c.original_segment || c.segment).toLowerCase().includes(search)
        );
    }

    return filtered;
}
// Render table
    function renderTable() {
        const data = getFilteredData(); // Obține datele filtrate
        updateStats(data); // <-- ACTUALIZEAZĂ STATISTICILE cu datele filtrate
        
        const totalPages = Math.ceil(data.length / rowsPerPage);
        const start = (currentPage - 1) * rowsPerPage;
        const pageData = data.slice(start, start + rowsPerPage);
        
        document.getElementById('customersTableBody').innerHTML = pageData.map((c, idx) => {
            const rowClass = c.no_orders_after_complaint ? 'no-orders-after-complaint' : '';
            const segmentClass = 'segment-' + c.segment // <-- AFIȘEAZĂ segmentul corect
                .toLowerCase().replace(/[^a-z]/g, '').replace('champions', 'vip');
            
            const emailDisplay = c.has_email ? 
                (c.email.length > 30 ? c.email.substring(0,30) + '...' : c.email) :
                '<span class="text-gray-500">N/A</span>';
            
            const complaintInfo = c.has_complaint ? 
                `<span class="text-red-400 cursor-help" title="${c.complaints.length} reclamații">DA (${
                    c.last_complaint_date ? new Date(c.last_complaint_date).toLocaleDateString('ro-RO') : 'Invalid'
                })</span>` : 
                '<span class="text-gray-500">NU</span>';
            
            let statusPostComplaint = '<span class="text-gray-500">-</span>';
            if (c.has_complaint) {
                statusPostComplaint = c.no_orders_after_complaint ? 
                    '<span class="text-red-500 font-bold">⚠ PIERDUT</span>' : 
                    '<span class="text-green-400">✔ ACTIV</span>';
            }
            
            const detailsForTooltip = JSON.stringify({
                ...c,
                displaySegment: c.segment // <-- AFIȘEAZĂ segmentul corect și în tooltip
            }).replace(/"/g, '&quot;');

            return `<tr class="${rowClass}">
                <td class="px-4 py-2 text-gray-500">${start + idx + 1}</td>
                <td class="px-4 py-2 font-mono text-blue-400">${c.id}</td>
                <td class="px-4 py-2 text-xs">${emailDisplay}</td>
                <td class="px-4 py-2"><span class="segment-badge ${segmentClass}">${c.segment}</span></td>
                <td class="px-4 py-2 text-right">
                    <span class="cursor-help font-bold text-green-400" data-details='${detailsForTooltip}' onmouseover="showScoreTooltip(event)" onmouseout="hideScoreTooltip()">${c.score}</span>
                </td>
                <td class="px-4 py-2 text-right font-mono">${Math.round(c.score_components.trend)}</td>
                <td class="px-4 py-2 text-right text-xs">${new Date(c.first_purchase).toLocaleDateString('ro-RO')}</td>
                <td class="px-4 py-2 text-right text-xs">${new Date(c.last_purchase).toLocaleDateString('ro-RO')}</td>
                <td class="px-4 py-2 text-right">${c.recency}</td>
                <td class="px-4 py-2 text-right">${c.monetary.toFixed(0)}</td>
                <td class="px-4 py-2 text-right">${c.invoice_count || c.purchase_cycles}</td>
                <td class="px-4 py-2 text-right">${c.avg_order_value.toFixed(0)}</td>
                <td class="px-4 py-2 text-center">${complaintInfo}</td>
                <td class="px-4 py-2">${statusPostComplaint}</td>
                <td class="px-4 py-2 text-center">
                  <button onclick="generateClientStory('${c.id}')" class="pagination-btn px-2 py-1 text-xs rounded">Analiză</button>
                </td>
            </tr>`;
        }).join('');
        
        renderPagination(totalPages, data.length);
    }

    // Render pagination
    function renderPagination(totalPages, totalResults) {
        const pagination = document.getElementById('pagination');
        if (totalPages <= 1) {
            pagination.innerHTML = `<div class="text-sm text-center text-gray-400">Afișare ${totalResults} rezultate</div>`;
            return;
        }
        
        pagination.innerHTML = `
            <div class="flex justify-between items-center">
                <div class="text-sm text-gray-400">Pagina ${currentPage} / ${totalPages} (${totalResults} rezultate)</div>
                <div class="flex items-center space-x-2">
                    <button ${currentPage === 1 ? 'disabled' : ''} 
                            onclick="changePage(${currentPage - 1})" 
                            class="pagination-btn px-3 py-1 rounded">←</button>
                    <button ${currentPage === totalPages ? 'disabled' : ''} 
                            onclick="changePage(${currentPage + 1})" 
                            class="pagination-btn px-3 py-1 rounded">→</button>
                </div>
            </div>`;
    }

    // Change page
    function changePage(page) {
        currentPage = page;
        renderTable();
    }

    // Update statistics
    function updateStats() {
        const withEmail = customersData.filter(c => c.has_email).length;
        const withoutEmail = customersData.length - withEmail;
        
        document.getElementById('totalCustomers').textContent = customersData.length.toLocaleString('ro-RO');
        document.getElementById('withEmail').textContent = withEmail.toLocaleString('ro-RO');
        document.getElementById('withoutEmail').textContent = withoutEmail.toLocaleString('ro-RO');
        document.getElementById('statTotalCustomers').textContent = customersData.length.toLocaleString('ro-RO');
        
        const segments = {
            'VIP Champions': 0, 'At Risk': 0, 'Lost': 0
        };
        let withComplaints = 0, noOrdersAfter = 0, totalValue = 0;
        
        customersData.forEach(c => {
            const seg = c.original_segment || c.segment;
            if (segments.hasOwnProperty(seg)) segments[seg]++;
            if (c.has_complaint) withComplaints++;
            if (c.no_orders_after_complaint) noOrdersAfter++;
            totalValue += c.avg_order_value;
        });
        
        document.getElementById('statChampions').textContent = segments['VIP Champions'].toLocaleString('ro-RO');
        document.getElementById('statAtRisk').textContent = segments['At Risk'].toLocaleString('ro-RO');
        document.getElementById('statLost').textContent = segments['Lost'].toLocaleString('ro-RO');
        document.getElementById('statComplaints').textContent = withComplaints.toLocaleString('ro-RO');
        document.getElementById('statNoOrdersAfterComplaint').textContent = noOrdersAfter.toLocaleString('ro-RO');
        document.getElementById('statAvgValue').textContent = 
            customersData.length > 0 ? Math.round(totalValue / customersData.length).toLocaleString('ro-RO') : '0';
        
        // Calculate seasonality
        const monthlyOrders = {};
        customersData.forEach(c => {
            c.transactions.forEach(t => {
                const month = new Date(t.date).getMonth();
                monthlyOrders[month] = (monthlyOrders[month] || 0) + 1;
            });
        });
        
        const maxMonth = Object.keys(monthlyOrders).reduce((max, m) => 
            monthlyOrders[m] > monthlyOrders[max] ? m : max, 0);
        const months = ['Ian','Feb','Mar','Apr','Mai','Iun','Iul','Aug','Sep','Oct','Nov','Dec'];
        document.getElementById('statSeasonality').textContent = months[maxMonth];
    }

    // Render charts
    function renderCharts() {
        // Segments chart
        const segmentCounts = {};
        customersData.forEach(c => {
            const seg = c.original_segment || c.segment;
            segmentCounts[seg] = (segmentCounts[seg] || 0) + 1;
        });
        
        const withComplaints = customersData.filter(c => c.has_complaint);
        const noOrdersAfter = withComplaints.filter(c => c.no_orders_after_complaint).length;
        
        // Destroy existing charts
        if (segmentsChart) segmentsChart.destroy();
        if (complaintsChart) complaintsChart.destroy();
        
        // Create segments chart
        const ctx1 = document.getElementById('segmentsChart').getContext('2d');
        segmentsChart = new Chart(ctx1, {
            type: 'doughnut',
            data: {
                labels: Object.keys(segmentCounts),
                datasets: [{
                    data: Object.values(segmentCounts),
                    backgroundColor: [
                        '#fbbf24', '#3b82f6', '#8b5cf6', '#10b981', 
                        '#f97316', '#ef4444', '#6b7280', '#991b1b', '#dc2626'
                    ]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: { color: '#e5e7eb', font: { size: 11 } }
                    }
                }
            }
        });
        
        // Create complaints chart
        const ctx2 = document.getElementById('complaintsChart').getContext('2d');
        complaintsChart = new Chart(ctx2, {
            type: 'bar',
            data: {
                labels: ['Fără Reclamații', 'Activi după Recl.', 'Pierduți după Recl.'],
                datasets: [{
                    data: [
                        customersData.length - withComplaints.length,
                        withComplaints.length - noOrdersAfter,
                        noOrdersAfter
                    ],
                    backgroundColor: ['#10b981', '#fbbf24', '#ef4444']
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    y: { ticks: { color: '#9ca3af' } },
                    x: { ticks: { color: '#9ca3af' } }
                }
            }
        });
    }

    // Show score tooltip
    function showScoreTooltip(event) {
        const details = JSON.parse(event.target.dataset.details);
        const tooltip = document.getElementById('scoreTooltip');
        
        tooltip.innerHTML = `
            <div class="text-green-400 font-bold mb-2">Scor Complex: ${details.score}</div>
            <div class="space-y-1">
                <div class="flex justify-between">
                    <span>Recență (30%):</span>
                    <span class="text-yellow-400">${details.score_components.recency}</span>
                </div>
                <div class="flex justify-between">
                    <span>Val. Medie (25%):</span>
                    <span class="text-blue-400">${details.score_components.avgOrder}</span>
                </div>
                <div class="flex justify-between">
                    <span>Cross-sell (15%):</span>
                    <span class="text-purple-400">${details.score_components.crossSell}</span>
                </div>
                <div class="flex justify-between">
                    <span>Vechime (10%):</span>
                    <span class="text-gray-400">${details.score_components.lifetime}</span>
                </div>
                <div class="flex justify-between">
                    <span>Tip Produs (10%):</span>
                    <span class="text-orange-400">${details.score_components.productType}</span>
                </div>
                <div class="flex justify-between">
                    <span>Trend (5%):</span>
                    <span class="text-pink-400">${details.score_components.trend}</span>
                </div>
                <div class="flex justify-between">
                    <span>Cicluri (5%):</span>
                    <span class="text-indigo-400">${details.score_components.cycles}</span>
                </div>
            </div>
            <div class="mt-2 pt-2 border-t border-gray-700">
                <div class="text-xs text-gray-400">
                    RFM: R=${details.rfm_score.r} F=${details.rfm_score.f} M=${details.rfm_score.m}
                </div>
                <div class="text-xs text-gray-400">
                    Segment: ${details.displaySegment}
                </div>
            </div>`;
        
        tooltip.style.display = 'block';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY + 10 + 'px';
    }

    // Hide score tooltip
    function hideScoreTooltip() {
        document.getElementById('scoreTooltip').style.display = 'none';
    }

    // Export results
    function exportResults() {
        const data = getFilteredData();
        if (data.length === 0) {
            alert('Nu există date pentru export!');
            return;
        }
        
        const csv = Papa.unparse(data.map(c => ({
            'ID Client': c.id,
            'Email': c.email,
            'Are Email': c.has_email ? 'DA' : 'NU',
            'Segment': c.original_segment || c.segment,
            'Scor': c.score,
            'Ultima Achiziție': new Date(c.last_purchase).toLocaleDateString('ro-RO'),
            'Zile Inactiv': c.recency,
            'Valoare Totală': c.monetary.toFixed(2),
            'Nr. Facturi': c.invoice_count || c.purchase_cycles,
            'Valoare Medie': c.avg_order_value.toFixed(2),
            'Tip Client': c.customer_type,
            'Are Reclamație': c.has_complaint ? 'DA' : 'NU',
            'Pierdut după Reclamație': c.no_orders_after_complaint ? 'DA' : 'NU'
        })));
        
        const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `mobexpert_crm_export_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
    }

    // Loading functions
    function showLoading(text) {
        document.getElementById('loadingOverlay').style.display = 'flex';
        document.getElementById('loadingText').textContent = text;
    }

    function updateLoading(text, details, percent) {
        document.getElementById('loadingText').textContent = text;
        document.getElementById('loadingDetails').textContent = details;
        document.getElementById('loadingProgress').style.width = percent + '%';
    }

    function hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
    }
      // --- FUNCȚII PENTRU POVESTEA CLIENTULUI (v2.0 - INTELIGENTĂ) ---

 function showStoryModal(storyHtml) {
    document.getElementById('storyContent').innerHTML = storyHtml;
    document.getElementById('storyOverlay').style.display = 'flex';
    // Forțăm scroll la început
    document.getElementById('storyContent').scrollTop = 0;
}

    function hideStoryModal() {
        document.getElementById('storyOverlay').style.display = 'none';
    }
function generateClientStory(customerId) {
    const c = customersData.find(cust => cust.id == customerId);
    if (!c) return;

    if (c.transactions.length < 3) {
        alert('Istoric insuficient pentru analiză detaliată.');
        return;
    }

    const now = new Date('2025-09-20');
    const firstPurchaseDate = new Date(c.first_purchase);
    const lastPurchaseDate = new Date(c.last_purchase);
    const daysSinceLastPurchase = Math.floor((now - lastPurchaseDate) / (1000 * 60 * 60 * 24));
    const totalLifetimeDays = Math.floor((lastPurchaseDate - firstPurchaseDate) / (1000 * 60 * 60 * 24));
    
    const sortedTransactions = [...c.transactions].sort((a, b) => new Date(a.date) - new Date(b.date));
    
    // Calculează intervalul mediu real între achiziții
    const intervals = [];
    for (let i = 1; i < sortedTransactions.length; i++) {
        const days = Math.floor((new Date(sortedTransactions[i].date) - new Date(sortedTransactions[i-1].date)) / (1000 * 60 * 60 * 24));
        if (days > 0) intervals.push(days);
    }
    const avgInterval = intervals.length > 0 ? Math.round(intervals.reduce((a, b) => a + b, 0) / intervals.length) : 0;
    
    // Categorizare achiziții Home & Deco
    const mobilierPrincipal = sortedTransactions.filter(t => t.value >= 6000);
    const mobilierMic = sortedTransactions.filter(t => t.value >= 500 && t.value < 6000);
    const decoratiuni = sortedTransactions.filter(t => t.value < 500);
    
    // Calculează trend doar dacă are suficient istoric
    let trendInfo = '';
    if (c.transactions.length >= 10) {
        trendInfo = `
            <div class="flex justify-between">
                <span class="text-gray-400">Scor Trend (0-100):</span>
                <span class="text-white font-bold">${c.trend_monetary}</span>
            </div>
            <div class="text-xs text-gray-500 mt-1">
                Pattern: ${c.trend_pattern || 'stable'} | 
                Încredere: ${c.trend_confidence || 'low'}
            </div>
        `;
    }
    
    // Analiză predictivă bazată pe ritmicitate
    let predictieAchizitie = '';
    if (avgInterval > 0 && intervals.length >= 3) {
        const daysUntilNext = avgInterval - daysSinceLastPurchase;
        
        if (daysUntilNext < -90) {
            predictieAchizitie = `
                <div class="p-2 bg-red-900/30 rounded border border-red-500/30">
                    <span class="text-red-400 text-xs">
                        Bazat pe ritmul anterior (achiziție la ~${avgInterval} zile), clientul a depășit 
                        perioada obișnuită cu ${Math.abs(daysUntilNext)} zile.
                    </span>
                </div>
            `;
        } else if (daysUntilNext <= 0 && daysUntilNext > -30) {
            predictieAchizitie = `
                <div class="p-2 bg-yellow-900/30 rounded border border-yellow-500/30">
                    <span class="text-yellow-400 text-xs">
                        Bazat pe istoricul de ${intervals.length} intervale, clientul ar putea fi interesat 
                        de o nouă achiziție în această perioadă.
                    </span>
                </div>
            `;
        } else if (daysUntilNext > 0 && daysUntilNext <= 30) {
            predictieAchizitie = `
                <div class="p-2 bg-green-900/30 rounded border border-green-500/30">
                    <span class="text-green-400 text-xs">
                        Conform ritmului observat, următoarea achiziție ar putea fi în aproximativ 
                        ${Math.round(daysUntilNext / 7)} săptămâni.
                    </span>
                </div>
            `;
        } else if (daysUntilNext > 30) {
            const months = Math.round(daysUntilNext / 30);
            predictieAchizitie = `
                <div class="p-2 bg-gray-900/30 rounded border border-gray-500/30">
                    <span class="text-gray-400 text-xs">
                        Pe baza intervalului mediu de ${avgInterval} zile, următoarea interacțiune 
                        ar putea fi peste aproximativ ${months} ${months === 1 ? 'lună' : 'luni'}.
                    </span>
                </div>
            `;
        }
    }
    
    // Analiză reclamații detaliată
    let reclamatiiInfo = '';
    if (c.has_complaint) {
        const lastComplaintDate = new Date(c.last_complaint_date);
        const daysAfterComplaint = Math.floor((lastPurchaseDate - lastComplaintDate) / (1000 * 60 * 60 * 24));
        
        reclamatiiInfo = `
            <div class="bg-gradient-to-r from-red-900/20 to-transparent p-4 rounded-lg border-l-4 border-red-500">
                <h4 class="text-sm font-bold text-red-400 mb-2">📋 Istoric Reclamații</h4>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Număr total reclamații:</span>
                        <span class="text-white font-bold">${c.complaints.length}</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Ultima reclamație:</span>
                        <span class="text-white">${lastComplaintDate.toLocaleDateString('ro-RO')}</span>
                    </div>
                    ${c.no_orders_after_complaint ? 
                        `<div class="mt-2 p-2 bg-red-900/50 rounded">
                            <span class="text-red-400 font-bold text-xs">
                                ⚠️ Nu a mai cumpărat după ultima reclamație (${Math.floor((now - lastComplaintDate) / (1000 * 60 * 60 * 24))} zile)
                            </span>
                        </div>` :
                        `<div class="mt-2 p-2 bg-green-900/30 rounded">
                            <span class="text-green-400 text-xs">
                                ✓ A continuat să cumpere după rezolvarea reclamației 
                                (${daysAfterComplaint > 0 ? `ultima achiziție după ${daysAfterComplaint} zile` : 'în aceeași zi'})
                            </span>
                        </div>`
                    }
                </div>
            </div>
        `;
    }
    
    // Grupare pe ani pentru evoluție
    const byYear = {};
    sortedTransactions.forEach(t => {
        const year = new Date(t.date).getFullYear();
        if (!byYear[year]) byYear[year] = { total: 0, count: 0, mobilier: 0, deco: 0 };
        byYear[year].total += t.value;
        byYear[year].count++;
        if (t.value >= 6000) byYear[year].mobilier++;
        else if (t.value < 500) byYear[year].deco++;
    });
    
    const years = Object.keys(byYear).sort().slice(-4);
    const maxYearValue = Math.max(...years.map(y => byYear[y].total));
    
    let evolutieHtml = '';
    years.forEach(year => {
        const data = byYear[year];
        const barWidth = (data.total / maxYearValue * 100).toFixed(0);
        evolutieHtml += `
            <div class="mb-3">
                <div class="flex justify-between text-xs mb-1">
                    <span class="text-gray-400">${year}</span>
                    <span class="text-white">${data.total.toFixed(0)} RON</span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-2">
                    <div class="bg-gradient-to-r from-green-600 to-green-400 h-2 rounded-full" 
                         style="width: ${barWidth}%"></div>
                </div>
                <div class="text-gray-500 text-xs mt-1">
                    ${data.count} facturi | ${data.mobilier} mobilier | ${data.deco} decorațiuni
                </div>
            </div>
        `;
    });

    // Generăm HTML-ul complet
    let storyHtml = `
        <div class="space-y-4">
            <!-- Header cu buton X -->
            <div class="flex justify-between items-start border-b border-gray-700 pb-3">
                <div>
                    <h3 class="text-lg font-bold text-green-400">Client ID: ${c.id}</h3>
                    <div class="text-xs text-gray-400 mt-1">
                        ${c.invoice_count} facturi • ${totalLifetimeDays} zile istoric • 
                        ${c.monetary.toFixed(0)} RON total
                    </div>
                </div>
             

            <!-- Compoziție achiziții Home & Deco -->
            <div class="bg-gradient-to-r from-blue-900/20 to-transparent p-4 rounded-lg border-l-4 border-blue-500">
                <h4 class="text-sm font-bold text-blue-400 mb-3">🛋️ Profil Achiziții Home & Deco</h4>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Mobilier Principal (≥6000 RON):</span>
                        <span class="text-white font-medium">${mobilierPrincipal.length} buc</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Mobilier Mic (500-6000 RON):</span>
                        <span class="text-white font-medium">${mobilierMic.length} buc</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Decorațiuni (<500 RON):</span>
                        <span class="text-white font-medium">${decoratiuni.length} buc</span>
                    </div>
                    <div class="flex justify-between mt-2 pt-2 border-t border-gray-700">
                        <span class="text-gray-400">Valoare medie/comandă:</span>
                        <span class="text-white font-bold">${c.avg_order_value.toFixed(0)} RON</span>
                    </div>
                    ${trendInfo}
                </div>
            </div>

            <!-- Evoluție temporală -->
            <div class="bg-gradient-to-r from-green-900/20 to-transparent p-4 rounded-lg border-l-4 border-green-500">
                <h4 class="text-sm font-bold text-green-400 mb-3">📈 Evoluție Anuală</h4>
                ${evolutieHtml}
            </div>

            <!-- Predicție bazată pe ritmicitate -->
            ${predictieAchizitie ? `
                <div class="bg-gradient-to-r from-yellow-900/20 to-transparent p-4 rounded-lg border-l-4 border-yellow-500">
                    <h4 class="text-sm font-bold text-yellow-400 mb-2">⏰ Analiză Ritmicitate</h4>
                    <div class="text-sm text-gray-300 mb-2">
                        Interval mediu istoric: ${avgInterval} zile | 
                        Ultima achiziție: acum ${daysSinceLastPurchase} zile
                    </div>
                    ${predictieAchizitie}
                </div>
            ` : ''}

            <!-- Reclamații dacă există -->
            ${reclamatiiInfo}
        </div>
    `;

    showStoryModal(storyHtml);
}
  // ============================================
// MOBEXPERT ML ENHANCED - LSTM & CLUSTERING

// ============================================



// Worker Code pentru procesare ML avansată

const MLWorkerCode = `

  importScripts('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js');



  // Configurație globală

  const CONFIG = {

    CLUSTERS: 30,

    SEQUENCE_LENGTH: 24, // ultimele 24 luni pentru LSTM

    BATCH_SIZE: 5000,

    LSTM_UNITS: 64,

    EMBEDDING_DIM: 32,

    SEASONALITY_FEATURES: 12, // features pentru fiecare lună

    CACHE_SIZE: 10000

  };



  // Cache pentru predicții

  const predictionCache = new Map();



  // 1. CLUSTERING PENTRU CATEGORII PRODUSE

  class ProductCategorizer {

    constructor() {

      this.categoryPatterns = this.initializePatterns();

      this.clusters = new Map();

      this.embeddings = new Map();

    }



 // Înlocuiește funcția initializePatterns() din ProductCategorizer

initializePatterns() {

  return {

    // DORMITOR

    'dormitor_mobilier': ['dormitor', 'mobila dormitor', 'mobilier dormitor', 'set dormitor'],

    'dormitor_apartament': ['apartament', 'garsoniera', 'studio', 'dormitor mic'],

    'paturi': ['pat', 'paturi', 'somiera', 'lada pat', 'pat tapitat', 'pat matrimonial', 'pat single'],

    'paturi_tapitate': ['pat tapitat', 'pat textil', 'pat stofa', 'pat catifea', 'pat piele'],

    'dulapuri': ['dulap', 'sifonier', 'garderoba', 'dulap haine'],

    'dressing': ['dressing', 'walk-in', 'sistem dressing', 'organizator'],

    'dulapuri_apartament': ['dulap mic', 'dulap 2 usi', 'dulap compact'],

    'noptiere': ['noptiera', 'noptiere', 'masuta noapte'],

    'comode_dormitor': ['comoda', 'comode', 'sertare', 'comoda sertare'],

    'oglinzi_dormitor': ['oglinda', 'oglinda dormitor', 'oglinda mare'],

    'masute_toaleta': ['masuta toaleta', 'masa toaleta', 'vanity', 'toaleta', 'masa machiaj'],



    // LIVING

    'living_mobilier': ['living', 'mobila living', 'mobilier living', 'set living'],

    'living_apartament': ['living mic', 'living compact', 'living studio'],

    'biblioteci': ['biblioteca', 'etajera', 'raft', 'rafturi', 'bookcase'],

    'vitrine_living': ['vitrina', 'vitrine', 'cristaliera', 'display'],

    'masute_living': ['masuta cafea', 'masuta living', 'coffee table', 'masuta centru'],

    'comode_tv': ['comoda tv', 'mobila tv', 'stand tv', 'suport tv', 'unitate tv'],

    'console': ['consola', 'console', 'masuta consola'],

    'polite': ['polita', 'polite', 'raft perete'],

    'seminee': ['semineu', 'seminee', 'fireplace', 'focar'],



    // DINING

    'dining_mobilier': ['dining', 'sufragerie', 'mobila dining', 'set dining'],

    'dining_apartament': ['dining mic', 'dining compact'],

    'mese_dining': ['masa dining', 'masa sufragerie', 'masa extensibila', 'masa', 'mese'],

    'scaune_dining': ['scaun', 'scaune', 'scaun dining', 'scaune sufragerie'],

    'scaune_bar': ['scaun bar', 'scaune bar', 'barstool', 'taburet bar'],

    'baruri': ['bar', 'minibar', 'mobila bar', 'bar casa'],

    'bufete': ['bufet', 'bufete', 'sideboard', 'credenza'],

    'vitrine_dining': ['vitrina dining', 'vitrina sufragerie'],

    'masute_mobile': ['masuta mobila', 'cart', 'carucior', 'masuta rotile'],



    // BUCĂTĂRIE

    'bucatarie_mobilier': ['bucatarie', 'mobila bucatarie', 'mobilier bucatarie'],

    'game_bucatarie': ['gama bucatarie', 'set bucatarie', 'ansamblu bucatarie'],

    'bucatarie_apartament': ['bucatarie mica', 'bucatarie compact', 'kitchenette'],

    'bucatarii_complete': ['bucatarie completa', 'bucatarie echipata'],

    'scaune_bucatarie': ['scaun bucatarie', 'scaune bucatarie'],

    'mese_bucatarie': ['masa bucatarie', 'mese bucatarie', 'dining table'],



    // HOL

    'hol_mobilier': ['hol', 'mobila hol', 'vestibul', 'antreu', 'mobilier hol'],

    'cuiere': ['cuier', 'cuiere', 'agatator', 'suport haine'],

    'oglinzi_hol': ['oglinda hol', 'oglinda vestibul', 'oglinda antreu'],

    'console_hol': ['consola hol', 'masuta hol'],

    'canapele_hol': ['canapea hol', 'fotoliu hol', 'bancheta hol', 'taburet hol'],

    'comode_pantofi': ['comoda pantofi', 'pantofar', 'suport pantofi', 'dulap pantofi'],



    // BAIE

    'baie_mobilier': ['baie', 'mobila baie', 'mobilier baie', 'set baie'],

    'lavoare': ['lavoar', 'lavoare', 'chiuveta baie', 'bazin'],

    'mobilier_spalatorie': ['spalatorie', 'mobila spalatorie', 'dulap spalatorie'],

    'cazi': ['cada', 'cada baie', 'bathtub', 'jacuzzi'],

    'baterii': ['baterie', 'baterii', 'robinet', 'mixer'],

    'vase_toaleta': ['vas toaleta', 'wc', 'toaleta', 'bideu'],

    'cabine_dus': ['cabina dus', 'sistem dus', 'shower'],

    'cadite': ['cadita', 'cadita dus', 'tava dus'],

    'radiatoare': ['radiator', 'radiator baie', 'calorifer', 'prosop radiator'],

    'oglinzi_baie': ['oglinda baie', 'oglinda led', 'oglinda iluminata'],

    'accesorii_baie': ['accesorii baie', 'dozator sapun', 'suport prosop'],



    // BIROU

    'birou_mobilier': ['birou', 'mobila birou', 'mobilier office', 'desk'],

    'birouri_operationale': ['birou operational', 'birou angajat', 'workstation'],

    'birouri_manageriale': ['birou manager', 'birou director', 'executive desk'],

    'birou_acasa': ['birou acasa', 'home office', 'birou personal'],

    'mese_consiliu': ['masa consiliu', 'masa sedinta', 'conference table'],

    'depozitare_birou': ['dulap birou', 'etajera birou', 'filing cabinet', 'sertar birou'],

    'scaune_operationale': ['scaun operational', 'scaun birou', 'office chair'],

    'scaune_manageriale': ['scaun manager', 'scaun director', 'executive chair'],

    'scaune_consiliu': ['scaun consiliu', 'scaun conferinta'],

    'scaune_gaming': ['scaun gaming', 'gaming chair', 'gamer'],

    'scaune_birou_acasa': ['scaun birou acasa', 'scaun home office'],

    'zona_asteptare': ['asteptare', 'waiting', 'lounge', 'receptie'],

    'masute_birou': ['masuta birou', 'side table', 'masuta laptop'],



    // CANAPELE

    'canapele_toate': ['canapea', 'sofa', 'canapele', 'divan'],

    'canapele_extensibile': ['canapea extensibila', 'sofa bed', 'canapea pat'],

    'coltare': ['coltar', 'coltare', 'sectional', 'canapea coltar'],

    'canapele_apartament': ['canapea mica', 'canapea 2 locuri', 'loveseat'],

    'canapele_stofa': ['canapea stofa', 'canapea textil', 'fabric sofa'],

    'canapele_piele': ['canapea piele', 'leather sofa', 'piele naturala', 'piele eco'],

    'canapele_recliner': ['recliner', 'canapea recliner', 'balansoar', 'rocking chair'],

    'canapele_clic_clac': ['clic clac', 'click clack', 'canapea clic'],

    'fotolii': ['fotoliu', 'fotolii', 'armchair', 'sezlong', 'chaise'],

    'banchete': ['bancheta', 'banchete', 'bench', 'ottoman'],

    'taburete': ['taburet', 'taburete', 'puf', 'pouf', 'stool'],



    // COVOARE

    'covoare_camera': ['covor', 'covoare', 'mocheta', 'carpet', 'rug'],

    'covoare_ziegler': ['ziegler', 'covor ziegler', 'persian'],

    'covoare_copii': ['covor copii', 'covor camera copii', 'kids rug'],

    'covoare_piele': ['covor piele', 'piele naturala', 'leather rug'],

    'covoare_bucatarie': ['covor bucatarie', 'kitchen rug', 'traversa bucatarie'],

    'covoare_exterior': ['covor exterior', 'outdoor rug', 'terasa'],

    'covoare_intrare': ['pres', 'covor intrare', 'doormat', 'covoras intrare'],

    'covorase_baie': ['covoras baie', 'bathroom rug', 'antiderapant'],



    // ILUMINAT

    'lustre': ['lustra', 'lustre', 'chandelier', 'candelabru'],

    'pendule': ['pendula', 'pendant', 'pendul', 'hanging lamp'],

    'plafoniere': ['plafoniera', 'ceiling light', 'spot', 'spoturi'],

    'aplice': ['aplica', 'aplice', 'wall light', 'lampa perete'],

    'veioze': ['veioza', 'veioze', 'table lamp', 'lampa masa'],

    'lampadare': ['lampadar', 'floor lamp', 'lampa podea'],

    'iluminat_copii': ['lampa copii', 'veioza copii', 'kids lamp'],

    'lampi_exterior': ['lampa exterior', 'outdoor light', 'felinar'],

    'abajururi': ['abajur', 'shade', 'baza lampa'],

    'lampi_birou': ['lampa birou', 'desk lamp', 'lampa citit'],

    'becuri': ['bec', 'becuri', 'bulb', 'led', 'halogen'],



    // SERVEȘTE MASA

    'pentru_gatit': ['tigaie', 'oala', 'cratita', 'cookware', 'vas gatit'],

    'pentru_bucatarie': ['recipient', 'cutie', 'borcan', 'ustensile', 'lingura', 'furculita'],

    'vesela': ['farfurie', 'ceasca', 'cana', 'pahar', 'set vesela', 'portelan'],

    'decoratiuni_masa': ['servet', 'fata masa', 'inel servetel', 'runner'],



    // SOMN ȘI BAIE

    'saltele': ['saltea', 'saltele', 'mattress', 'arcuri', 'memory foam', 'latex'],

    'lenjerii': ['lenjerie pat', 'cearsaf', 'fata perna', 'set lenjerie', 'bedding'],

    'pilote_perne': ['pilota', 'perna', 'plapuma', 'duvet', 'pillow'],

    'protectii': ['protectie saltea', 'topper', 'husa saltea'],

    'halate_prosoape': ['halat', 'prosop', 'bathrobe', 'towel'],



    // DECORAȚIUNI

    'perne_decorative': ['perna decorativa', 'fata perna', 'cushion', 'throw pillow'],

    'pleduri': ['pled', 'patura', 'cuvertura', 'throw', 'blanket'],

    'asternuturi': ['asternut', 'cuvertura pat', 'husa plapuma', 'bedspread'],

    'tablouri': ['tablou', 'poster', 'rama', 'canvas', 'picture', 'arta', 'art'],

    'oglinzi_decorative': ['oglinda decorativa', 'mirror', 'oglinda design'],

    'ceasuri_perete': ['ceas perete', 'pendula', 'wall clock'],

    'corpuri_decor': ['vaza', 'bol', 'statueta', 'figurina', 'obiect decorativ'],

    'suporturi_rafturi': ['suport', 'raft decorativ', 'shelf', 'etajera decorativa'],

    'vaze_ghivece': ['vaza', 'ghiveci', 'jardiniera', 'planter', 'pot'],

    'suporturi_foto': ['rama foto', 'suport fotografie', 'photo frame'],

    'decoratiuni_sezon': ['craciun', 'paste', 'halloween', 'brad', 'globuri', 'ornament'],



    // EXTERIOR

    'mobilier_exterior': ['exterior', 'gradina', 'terasa', 'outdoor', 'garden'],

    'seturi_exterior': ['set gradina', 'set terasa', 'patio set'],

    'canapele_exterior': ['canapea exterior', 'fotoliu exterior', 'outdoor sofa'],

    'sezlonguri': ['sezlong', 'lounger', 'deck chair', 'plaja'],

    'masute_exterior': ['masuta exterior', 'outdoor table'],

    'mese_scaune_exterior': ['masa gradina', 'scaun gradina', 'garden chair'],

    'leagane': ['leagan', 'balansoar', 'swing', 'hammock'],

    'decoratiuni_exterior': ['decor gradina', 'solar', 'fantana'],

    'plante_ghivece': ['planta', 'ghiveci', 'flori', 'jardiniera']

  };

}



    extractFeatures(text) {

      if (!text) return [];

      const normalized = text.toLowerCase()

        .replace(/[^a-z0-9ăâîșț ]/g, ' ')

        .replace(/\\s+/g, ' ')

        .trim();

      

      const words = normalized.split(' ').filter(w => w.length > 2);

      const bigrams = [];

      for (let i = 0; i < words.length - 1; i++) {

        bigrams.push(words[i] + ' ' + words[i + 1]);

      }

      

      return [...words, ...bigrams];

    }



    categorize(productName) {

      const features = this.extractFeatures(productName);

      const scores = {};

      

      for (const [category, patterns] of Object.entries(this.categoryPatterns)) {

        scores[category] = 0;

        for (const pattern of patterns) {

          if (features.some(f => f.includes(pattern))) {

            scores[category] += pattern.split(' ').length; // bigrams score higher

          }

        }

      }

      

      // Get top category

      let maxScore = 0;

      let bestCategory = 'general';

      

      for (const [cat, score] of Object.entries(scores)) {

        if (score > maxScore) {

          maxScore = score;

          bestCategory = cat;

        }

      }

      

      // Calculate confidence

      const totalScore = Object.values(scores).reduce((a, b) => a + b, 0);

      const confidence = totalScore > 0 ? maxScore / totalScore : 0;

      

      return {

        category: bestCategory,

        confidence: confidence,

        scores: scores

      };

    }



    buildClusters(products) {

      const categoryGroups = {};

      

      for (const product of products) {

        const result = this.categorize(product.name);

        if (!categoryGroups[result.category]) {

          categoryGroups[result.category] = [];

        }

        categoryGroups[result.category].push({

          ...product,

          confidence: result.confidence

        });

      }

      

      // Calculate category statistics

      for (const [cat, items] of Object.entries(categoryGroups)) {

        this.clusters.set(cat, {

          items: items,

          avgPrice: items.reduce((sum, i) => sum + i.price, 0) / items.length,

          avgCycle: this.estimatePurchaseCycle(cat),

          seasonality: this.detectSeasonality(items),

          count: items.length

        });

      }

      

      return this.clusters;

    }



    estimatePurchaseCycle(category) {

      const cycles = {

        'dormitor': 84, 'living': 72, 'bucatarie': 60,

        'birou': 48, 'baie': 36, 'exterior': 24,

        'lenjerie': 12, 'perdele': 36, 'covoare': 48,

        'iluminat': 36, 'arta': 0, 'oglinzi': 60,

        'decoratiuni': 6, 'craciun': 12, 'paste': 12,

        'copii': 18, 'premium': 60, 'eco': 24

      };

      return cycles[category] || 24;

    }



    detectSeasonality(items) {

      const monthCounts = new Array(12).fill(0);

      items.forEach(item => {

        if (item.date) {

          const month = new Date(item.date).getMonth();

          monthCounts[month]++;

        }

      });

      

      const total = monthCounts.reduce((a, b) => a + b, 0);

      return monthCounts.map(count => count / total);

    }

  }



  // 2. LSTM MODEL PENTRU PREDICȚII

  class LSTMPredictor {

    constructor() {

      this.model = null;

      this.isTraining = false;

      this.featureScaler = { mean: {}, std: {} };

    }



    async buildModel() {

      this.model = tf.sequential({

        layers: [

          tf.layers.lstm({

            units: CONFIG.LSTM_UNITS,

            returnSequences: true,

            inputShape: [CONFIG.SEQUENCE_LENGTH, 15] // 15 features

          }),

          tf.layers.dropout({ rate: 0.2 }),

          tf.layers.lstm({

            units: 32,

            returnSequences: false

          }),

          tf.layers.dropout({ rate: 0.2 }),

          tf.layers.dense({

            units: 16,

            activation: 'relu'

          }),

          tf.layers.dense({

            units: 4, // 4 outputs: prob_3m, prob_6m, prob_12m, value

            activation: 'sigmoid'

          })

        ]

      });



      this.model.compile({

        optimizer: tf.train.adam(0.001),

        loss: 'meanSquaredError',

        metrics: ['mae']

      });



      return this.model;

    }



    prepareSequences(customerData) {

      const sequences = [];

      const sortedTransactions = customerData.transactions.sort((a, b) => 

        new Date(a.date) - new Date(b.date)

      );



      // Create monthly aggregation

      const monthlyData = {};

      sortedTransactions.forEach(t => {

        const date = new Date(t.date);

        const key = date.getFullYear() + '-' + (date.getMonth() + 1);

        if (!monthlyData[key]) {

          monthlyData[key] = {

            value: 0,

            count: 0,

            categories: new Set(),

            avgValue: 0

          };

        }

        monthlyData[key].value += t.value;

        monthlyData[key].count++;

        if (t.category) monthlyData[key].categories.add(t.category);

      });



      // Convert to sequence

      const months = Object.keys(monthlyData).sort();

      

      if (months.length < CONFIG.SEQUENCE_LENGTH) {

        // Pad with zeros for short sequences

        const padding = CONFIG.SEQUENCE_LENGTH - months.length;

        for (let i = 0; i < padding; i++) {

          sequences.push(this.createFeatureVector(null));

        }

      }



      // Add actual data

      months.slice(-CONFIG.SEQUENCE_LENGTH).forEach(month => {

        const data = monthlyData[month];

        sequences.push(this.createFeatureVector(data, month));

      });



      return sequences;

    }



    createFeatureVector(data, month) {

      if (!data) {

        return new Array(15).fill(0);

      }



      const date = month ? new Date(month + '-01') : new Date();

      const features = [

        data.value / 10000, // normalized value

        data.count / 10, // normalized count

        data.value / Math.max(data.count, 1) / 5000, // avg value

        data.categories ? data.categories.size / 10 : 0, // category diversity

        Math.sin(2 * Math.PI * date.getMonth() / 12), // seasonal sin

        Math.cos(2 * Math.PI * date.getMonth() / 12), // seasonal cos

        date.getMonth() === 11 ? 1 : 0, // december flag

        date.getMonth() === 0 ? 1 : 0, // january flag

        date.getMonth() === 10 ? 1 : 0, // november (black friday)

        [2, 3, 4].includes(date.getMonth()) ? 1 : 0, // spring

        [5, 6, 7].includes(date.getMonth()) ? 1 : 0, // summer

        [8, 9, 10].includes(date.getMonth()) ? 1 : 0, // autumn

        date.getDay() / 7, // day of week normalized

        date.getDate() / 31, // day of month normalized

        1 // bias term

      ];



      return features;

    }



    async predict(customerData) {

      if (!this.model) {

        await this.buildModel();

      }



      // Check cache

      const cacheKey = customerData.id + '_' + customerData.recency;

      if (predictionCache.has(cacheKey)) {

        return predictionCache.get(cacheKey);

      }



      const sequences = this.prepareSequences(customerData);

      const input = tf.tensor3d([sequences]);

      

      const prediction = await this.model.predict(input).array();

      input.dispose();



      const result = {

        probability_3m: Math.round(prediction[0][0] * 100),

        probability_6m: Math.round(prediction[0][1] * 100),

        probability_12m: Math.round(prediction[0][2] * 100),

        estimated_value: Math.round(prediction[0][3] * 50000), // denormalize

        confidence: this.calculateConfidence(customerData),

        factors: this.explainPrediction(customerData, prediction[0])

      };



      // Cache result

      if (predictionCache.size > CONFIG.CACHE_SIZE) {

        const firstKey = predictionCache.keys().next().value;

        predictionCache.delete(firstKey);

      }

      predictionCache.set(cacheKey, result);



      return result;

    }



    calculateConfidence(data) {

      let score = 0;

      

      if (data.transactions.length >= 24) score += 40;

      else if (data.transactions.length >= 12) score += 30;

      else if (data.transactions.length >= 6) score += 20;

      else score += 10;



      if (data.customer_lifetime > 730) score += 30;

      else if (data.customer_lifetime > 365) score += 20;

      else score += 10;



      if (data.monetary > 50000) score += 30;

      else if (data.monetary > 20000) score += 20;

      else score += 10;



      if (score >= 80) return 'high';

      if (score >= 50) return 'medium';

      return 'low';

    }



    explainPrediction(data, prediction) {

      const factors = [];

      

      // Analyze prediction components

      if (prediction[0] > 0.7) {

        factors.push({ 

          type: 'positive', 

          text: 'Probabilitate foarte mare în 3 luni',

          impact: 'high'

        });

      }

      

      if (prediction[1] > prediction[0]) {

        factors.push({ 

          type: 'neutral', 

          text: 'Pattern de cumpărare la 6 luni',

          impact: 'medium'

        });

      }



      if (data.recency < 90) {

        factors.push({ 

          type: 'positive', 

          text: 'Client activ recent',

          impact: 'high'

        });

      } else if (data.recency > 365) {

        factors.push({ 

          type: 'negative', 

          text: 'Inactiv de peste 1 an',

          impact: 'high'

        });

      }



      // Seasonal factors

      const currentMonth = new Date().getMonth();

      if ([10, 11].includes(currentMonth)) {

        factors.push({ 

          type: 'positive', 

          text: 'Sezon de vânzări ridicate',

          impact: 'medium'

        });

      }



      // Category preferences

      if (data.preferred_categories && data.preferred_categories.includes('premium')) {

        factors.push({ 

          type: 'positive', 

          text: 'Client premium',

          impact: 'high'

        });

      }



      return factors;

    }

  }



  // 3. ORCHESTRATOR PRINCIPAL

  class MLOrchestrator {

    constructor() {

      this.categorizer = new ProductCategorizer();

      this.predictor = new LSTMPredictor();

      this.isInitialized = false;

    }



    async initialize() {

      if (this.isInitialized) return;

      

      await this.predictor.buildModel();

      this.isInitialized = true;

      

      self.postMessage({ 

        type: 'ml_status', 

        message: 'Model LSTM inițializat'

      });

    }



    async processCustomers(customers, transactions) {

      await this.initialize();

      

      // Step 1: Build product clusters

      self.postMessage({ 

        type: 'ml_progress', 

        percent: 10,

        message: 'Analiză categorii produse...'

      });



      const products = this.extractProducts(transactions);

      const clusters = this.categorizer.buildClusters(products);

      

      // Step 2: Enhance customer data with ML predictions

      const results = [];

      const batchSize = Math.min(CONFIG.BATCH_SIZE, customers.length);

      

      for (let i = 0; i < customers.length; i += batchSize) {

        const batch = customers.slice(i, i + batchSize);

        

        self.postMessage({ 

          type: 'ml_progress', 

          percent: 10 + (80 * i / customers.length),

          message: \`Predicții LSTM: \${i}/\${customers.length} clienți\`

        });



        const batchResults = await Promise.all(

          batch.map(async (customer) => {

            // Add category preferences

            customer.preferred_categories = this.getCustomerCategories(

              customer.transactions, 

              clusters

            );

            

            // Get LSTM predictions

            const predictions = await this.predictor.predict(customer);

            

            return {

              ...customer,

              ml_predictions: predictions,

              ml_category: customer.preferred_categories[0] || 'general',

              ml_next_purchase_month: this.predictNextMonth(predictions),

              ml_lifetime_value: this.calculateLTV(customer, predictions)

            };

          })

        );



        results.push(...batchResults);

      }



      self.postMessage({ 

        type: 'ml_complete', 

        data: results,

        clusters: Array.from(clusters.entries())

      });



      return results;

    }



    extractProducts(transactions) {

      const productMap = new Map();

      

      transactions.forEach(t => {

        if (t.product_name) {

          const key = t.product_name.toLowerCase();

          if (!productMap.has(key)) {

            productMap.set(key, {

              name: t.product_name,

              price: t.value,

              date: t.date,

              count: 1

            });

          } else {

            const existing = productMap.get(key);

            existing.count++;

            existing.price = (existing.price + t.value) / 2;

          }

        }

      });



      return Array.from(productMap.values());

    }



    getCustomerCategories(transactions, clusters) {

      const categoryCount = {};

      

      transactions.forEach(t => {

        if (t.product_name) {

          const result = this.categorizer.categorize(t.product_name);

          categoryCount[result.category] = (categoryCount[result.category] || 0) + 1;

        }

      });



      return Object.keys(categoryCount)

        .sort((a, b) => categoryCount[b] - categoryCount[a])

        .slice(0, 5);

    }



    predictNextMonth(predictions) {

      if (predictions.probability_3m > 70) return 3;

      if (predictions.probability_6m > 60) return 6;

      if (predictions.probability_12m > 50) return 12;

      return null;

    }



    calculateLTV(customer, predictions) {

      const avgOrderValue = customer.avg_order_value || 0;

      const expectedOrders = 

        (predictions.probability_3m / 100) + 

        (predictions.probability_6m / 100) * 0.8 + 

        (predictions.probability_12m / 100) * 0.6;

      

      return Math.round(avgOrderValue * expectedOrders * 1.2); // 1.2 growth factor

    }

  }



  // Main worker handler

  const orchestrator = new MLOrchestrator();



  self.onmessage = async function(e) {

    const { type, customers, transactions } = e.data;

    

    if (type === 'process_ml') {

      try {

        const results = await orchestrator.processCustomers(customers, transactions);

        self.postMessage({ type: 'ml_complete', data: results });

      } catch (error) {

        self.postMessage({ 

          type: 'ml_error', 

          error: error.message 

        });

      }

    }

  };

`;



// Funcții de integrare în UI-ul existent

window.MobexpertMLEnhanced = {

  worker: null,

  predictions: new Map(),



  // Inițializare worker

  init() {

    const blob = new Blob([MLWorkerCode], { type: 'application/javascript' });

    this.worker = new Worker(URL.createObjectURL(blob));

    

    this.worker.onmessage = (e) => {

      if (e.data.type === 'ml_complete') {

        this.handleMLResults(e.data.data);

      } else if (e.data.type === 'ml_progress') {

        this.updateProgress(e.data.percent, e.data.message);

      } else if (e.data.type === 'ml_error') {

        console.error('ML Error:', e.data.error);

      }

    };

  },



  // Procesare date cu ML

  processWithML(customersData, transactionsData) {

    this.worker.postMessage({

      type: 'process_ml',

      customers: customersData,

      transactions: transactionsData

    });

  },



  // Handle rezultate ML

  handleMLResults(enhancedData) {

    enhancedData.forEach(customer => {

      this.predictions.set(customer.id, customer.ml_predictions);

    });



    // Update tabel - adaugă coloane noi

    this.enhanceTableWithML();

    

    // Store pentru popup

    window.mlCustomersData = enhancedData;

  },



  // Adaugă coloane ML în tabel

  enhanceTableWithML() {

    // Modifică header-ul

    const thead = document.querySelector('.table-dark thead tr');

    if (thead && !document.getElementById('ml-headers')) {

      const mlHeaders = `

        <th id="ml-headers" class="px-2 py-4 text-center">

          <div class="text-purple-400">ML 3L</div>

        </th>

        <th class="px-2 py-4 text-center">

          <div class="text-purple-400">ML 6L</div>

        </th>

        <th class="px-2 py-4 text-center">

          <div class="text-purple-400">ML 12L</div>

        </th>

        <th class="px-2 py-4 text-center">

          <div class="text-purple-400">Val.Est</div>

        </th>

        <th class="px-2 py-4 text-center">

          <div class="text-purple-400">Categorie</div>

        </th>

        <th class="px-2 py-4 text-center">

          <div class="text-purple-400">ML Detail</div>

        </th>

      `;

      thead.insertAdjacentHTML('beforeend', mlHeaders);

    }

  },



  // Render celule ML pentru fiecare rând

  renderMLCells(customerId) {

    const pred = this.predictions.get(customerId);

    if (!pred) return '<td colspan="6" class="text-gray-500 text-xs">Processing...</td>';



    const confClass = pred.confidence === 'high' ? 'ml-high' : 

                      pred.confidence === 'medium' ? 'ml-medium' : 'ml-low';



    return `

      <td class="px-2 py-2 text-center">

        <span class="ml-badge ${pred.probability_3m > 70 ? 'ml-high' : pred.probability_3m > 40 ? 'ml-medium' : 'ml-low'}">

          ${pred.probability_3m}%

        </span>

      </td>

      <td class="px-2 py-2 text-center">

        <span class="ml-badge ${pred.probability_6m > 60 ? 'ml-high' : pred.probability_6m > 35 ? 'ml-medium' : 'ml-low'}">

          ${pred.probability_6m}%

        </span>

      </td>

      <td class="px-2 py-2 text-center">

        <span class="ml-badge ${pred.probability_12m > 50 ? 'ml-high' : pred.probability_12m > 30 ? 'ml-medium' : 'ml-low'}">

          ${pred.probability_12m}%

        </span>

      </td>

      <td class="px-2 py-2 text-center text-green-400 font-bold">

        ${(pred.estimated_value / 1000).toFixed(1)}k

      </td>

      <td class="px-2 py-2 text-center">

        <span class="text-xs text-purple-400">${window.mlCustomersData?.find(c => c.id === customerId)?.ml_category || '-'}</span>

      </td>

      <td class="px-2 py-2 text-center">

        <button onclick="MobexpertMLEnhanced.showMLPopup('${customerId}')" 

                class="pagination-btn px-2 py-1 text-xs rounded">

          🤖 ML

        </button>

      </td>

    `;

  },



  // Popup detaliat pentru predicții ML

  showMLPopup(customerId) {

    const customer = window.mlCustomersData?.find(c => c.id === customerId);

    if (!customer) return;



    const pred = customer.ml_predictions;

    const overlay = document.createElement('div');

    overlay.className = 'ml-overlay';

    overlay.onclick = () => overlay.remove();



    const popup = document.createElement('div');

    popup.className = 'ml-popup';

    popup.onclick = (e) => e.stopPropagation();



    popup.innerHTML = `

      <div class="flex justify-between items-start mb-4">

        <h2 class="text-xl font-bold text-purple-400">🤖 Analiză ML - Client ${customerId}</h2>

        <button onclick="this.closest('.ml-overlay').remove()" class="text-red-400 hover:text-red-300 text-xl">✕</button>

      </div>



      <div class="grid grid-cols-2 gap-4 mb-6">

        <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20">

          <h3 class="text-sm font-bold text-purple-300 mb-3">📊 Predicții Probabilitate Cumpărare</h3>

          <div class="space-y-2">

            <div class="flex justify-between items-center">

              <span class="text-gray-400">Următoarele 3 luni:</span>

              <div class="flex items-center gap-2">

                <div class="w-24 bg-gray-800 rounded-full h-2">

                  <div class="h-2 rounded-full ${pred.probability_3m > 70 ? 'bg-green-500' : pred.probability_3m > 40 ? 'bg-yellow-500' : 'bg-red-500'}" 

                       style="width: ${pred.probability_3m}%"></div>

                </div>

                <span class="font-bold text-white">${pred.probability_3m}%</span>

              </div>

            </div>

            <div class="flex justify-between items-center">

              <span class="text-gray-400">Următoarele 6 luni:</span>

              <div class="flex items-center gap-2">

                <div class="w-24 bg-gray-800 rounded-full h-2">

                  <div class="h-2 rounded-full ${pred.probability_6m > 60 ? 'bg-green-500' : pred.probability_6m > 35 ? 'bg-yellow-500' : 'bg-red-500'}" 

                       style="width: ${pred.probability_6m}%"></div>

                </div>

                <span class="font-bold text-white">${pred.probability_6m}%</span>

              </div>

            </div>

            <div class="flex justify-between items-center">

              <span class="text-gray-400">Următoarele 12 luni:</span>

              <div class="flex items-center gap-2">

                <div class="w-24 bg-gray-800 rounded-full h-2">

                  <div class="h-2 rounded-full ${pred.probability_12m > 50 ? 'bg-green-500' : pred.probability_12m > 30 ? 'bg-yellow-500' : 'bg-red-500'}" 

                       style="width: ${pred.probability_12m}%"></div>

                </div>

                <span class="font-bold text-white">${pred.probability_12m}%</span>

              </div>

            </div>

          </div>

        </div>



        <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20">

          <h3 class="text-sm font-bold text-purple-300 mb-3">💰 Valoare & Categorii</h3>

          <div class="space-y-2 text-sm">

            <div class="flex justify-between">

              <span class="text-gray-400">Valoare estimată:</span>

              <span class="text-green-400 font-bold">${pred.estimated_value.toLocaleString('ro-RO')} RON</span>

            </div>

            <div class="flex justify-between">

              <span class="text-gray-400">Categorie principală:</span>

              <span class="text-purple-400 font-bold">${customer.ml_category}</span>

            </div>

            <div class="flex justify-between">

              <span class="text-gray-400">LTV estimat:</span>

// Continuarea popup-ului ML

              <span class="text-yellow-400 font-bold">${customer.ml_lifetime_value?.toLocaleString('ro-RO') || '0'} RON</span>

            </div>

            <div class="flex justify-between">

              <span class="text-gray-400">Încredere predicție:</span>

              <span class="${pred.confidence === 'high' ? 'text-green-400' : pred.confidence === 'medium' ? 'text-yellow-400' : 'text-red-400'} font-bold">

                ${pred.confidence.toUpperCase()}

              </span>

            </div>

          </div>

        </div>

      </div>



      <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20 mb-6">

        <h3 class="text-sm font-bold text-purple-300 mb-3">🎯 Factori Cheie & Recomandări</h3>

        <div class="space-y-2">

          ${pred.factors.map(f => `

            <div class="flex items-start gap-2">

              <span class="${f.type === 'positive' ? 'text-green-400' : f.type === 'negative' ? 'text-red-400' : 'text-yellow-400'}">

                ${f.type === 'positive' ? '✅' : f.type === 'negative' ? '⚠️' : 'ℹ️'}

              </span>

              <div>

                <span class="text-gray-300 text-sm">${f.text}</span>

                ${f.impact === 'high' ? '<span class="ml-2 text-xs text-purple-400">(Impact ridicat)</span>' : ''}

              </div>

            </div>

          `).join('')}

        </div>

      </div>



      <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20">

        <h3 class="text-sm font-bold text-purple-300 mb-3">📈 Categorii Preferate (Top 5)</h3>

        <div class="flex flex-wrap gap-2">

          ${(customer.preferred_categories || []).map(cat => `

            <span class="px-3 py-1 bg-purple-900/30 text-purple-300 rounded-full text-xs border border-purple-500/30">

              ${cat}

            </span>

          `).join('')}

        </div>

      </div>



      <div class="mt-6 text-xs text-gray-500 text-center">

        Model: LSTM cu 2 layere | Sequence: 24 luni | Features: 15 | Confidence: ${pred.confidence}

      </div>

    `;



    overlay.appendChild(popup);

    document.body.appendChild(overlay);

  },



  // Update progress

  updateProgress(percent, message) {

    const loadingText = document.getElementById('loadingText');

    const loadingProgress = document.getElementById('loadingProgress');

    

    if (loadingText) loadingText.textContent = `ML: ${message}`;

    if (loadingProgress) loadingProgress.style.width = `${percent}%`;

  }

};



// Override funcția renderTable existentă pentru a include ML

const originalRenderTable = window.renderTable;

window.renderTable = function() {

  originalRenderTable();

  

  // Adaugă coloanele ML pentru fiecare rând

  const rows = document.querySelectorAll('#customersTableBody tr');

  rows.forEach((row, idx) => {

    const customerId = row.querySelector('td:nth-child(2)')?.textContent;

    if (customerId) {

      const mlCells = MobexpertMLEnhanced.renderMLCells(customerId);

      row.insertAdjacentHTML('beforeend', mlCells);

    }

  });

};



// Extinde procesarea CSV pentru a include ML

const originalProcessCsvFiles = window.processCsvFiles;

window.processCsvFiles = function(salesFiles, complaintsFile) {

  // Apelează funcția originală

  originalProcessCsvFiles.call(this, salesFiles, complaintsFile);

  

  // După ce datele sunt procesate, adaugă ML

  setTimeout(() => {

    if (window.customersData && window.customersData.length > 0) {

      // Extrage toate tranzacțiile cu denumiri produse

      const allTransactions = [];

      

      window.customersData.forEach(customer => {

        customer.transactions.forEach(t => {

          allTransactions.push({

            customer_id: customer.id,

            date: t.date,

            value: t.value,

            product_name: t.product_name || 'Unknown' // Trebuie extras din CSV

          });

        });

      });

      

      // Inițializează și procesează cu ML

      MobexpertMLEnhanced.init();

      MobexpertMLEnhanced.processWithML(window.customersData, allTransactions);

    }

  }, 1000);

};



// Helper pentru extragerea denumirii produselor din CSV

window.extractProductNameFromCSV = function(row) {

  // Caută în coloanele posibile

  const possibleColumns = [

    'DENUMIRE ARTICOL',

    'DENUMIRE_ARTICOL', 

    'Product Name',

    'Product',

    'Articol',

    'Produs'

  ];

  

  for (const col of possibleColumns) {

    if (row[col]) return row[col];

  }

  

  return 'Unknown';

};



// Modifică parserul CSV pentru a include denumirea produselor

const originalReadAndParseCSV = window.readAndParseCSV;

window.readAndParseCSV = function(file, type) {

  return originalReadAndParseCSV.call(this, file, type).then(data => {

    if (type === 'sales') {

      // Adaugă denumirea produsului la fiecare tranzacție

      return data.map(row => ({

        ...row,

        product_name: extractProductNameFromCSV(row)

      }));

    }

    return data;

  });

};



// Auto-init când documentul e ready

if (document.readyState === 'loading') {

  document.addEventListener('DOMContentLoaded', () => {

    console.log('🚀 ML Enhanced Module cu LSTM & Clustering ready');

  });

} else {

  console.log('🚀 ML Enhanced Module cu LSTM & Clustering ready');

}



// Export global pentru debugging

window.MLDebug = {

  getCache: () => MobexpertMLEnhanced.predictions,

  reprocess: () => {

    if (window.customersData) {

      MobexpertMLEnhanced.processWithML(window.customersData, []);

    }

  },

  testCategory: (productName) => {

    const categorizer = new ProductCategorizer();

    return categorizer.categorize(productName);

  }

};
    
</script>
</body>
</html>
